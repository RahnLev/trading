<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bar Flow Report - BarsOnTheFlow Strategy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 32px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .search-section {
            margin-bottom: 30px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #barInput {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        #barInput:focus {
            outline: none;
            border-color: #667eea;
        }

        #loadButton {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #loadButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        #loadButton:active {
            transform: translateY(0);
        }

        .error {
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 8px;
            padding: 15px;
            color: #c33;
            margin-bottom: 20px;
            display: none;
        }

        .bar-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .bar-info h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 24px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .position-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }

        .position-long {
            background: #d4edda;
            color: #155724;
        }

        .position-short {
            background: #f8d7da;
            color: #721c24;
        }

        .position-flat {
            background: #e2e3e5;
            color: #383d41;
        }

        .conditions-section {
            margin-bottom: 30px;
        }

        .conditions-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .condition-group {
            margin-bottom: 25px;
        }

        .condition-group-title {
            font-size: 16px;
            font-weight: 600;
            color: #555;
            margin-bottom: 12px;
            padding-left: 5px;
            border-left: 4px solid #667eea;
        }

        .condition {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            margin-bottom: 8px;
            border-radius: 8px;
            transition: transform 0.2s;
        }

        .condition:hover {
            transform: translateX(5px);
        }

        .condition.met {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }

        .condition.not-met {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }

        .condition.neutral {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .condition-icon {
            margin-right: 12px;
            font-size: 20px;
        }

        .condition-text {
            flex: 1;
            font-size: 15px;
            line-height: 1.5;
        }

        .condition-label {
            font-weight: 600;
            margin-right: 5px;
        }

        .condition-value {
            color: #666;
            font-family: 'Courier New', monospace;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            display: none;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #reportContent {
            display: none;
        }

        .trend-bars {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .trend-bar {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            border: 2px solid;
        }

        .trend-bar.good {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .trend-bar.bad {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Bar Flow Report</h1>
        <p class="subtitle">BarsOnTheFlow Strategy - Detailed Condition Analysis</p>

        <div class="search-section">
            <input type="number" id="barInput" placeholder="Enter bar number..." min="0">
            <button id="loadButton">Load Bar Report</button>
        </div>

        <div id="errorMsg" class="error"></div>
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Loading bar data...</p>
        </div>

        <div id="reportContent">
            <div class="bar-info">
                <h2>Bar Information</h2>
                <div class="info-grid">
                    <div class="info-item">
                        <span class="info-label">Bar Index</span>
                        <span class="info-value" id="barIndex">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Timestamp</span>
                        <span class="info-value" id="timestamp">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Position</span>
                        <span class="info-value" id="position">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Action</span>
                        <span class="info-value" id="action">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">OHLC</span>
                        <span class="info-value" id="ohlc">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Candle Type</span>
                        <span class="info-value" id="candleType">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Fast EMA</span>
                        <span class="info-value" id="fastEma">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">EMA Gradient</span>
                        <span class="info-value" id="emaGrad">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Volume</span>
                        <span class="info-value" id="volume">-</span>
                    </div>
                </div>
            </div>

            <div id="conditionsContainer"></div>
        </div>
    </div>

    <script>
        let latestLogFile = null;
            let strategyParams = null;

        // Get URL parameter if present
        const urlParams = new URLSearchParams(window.location.search);
        const barParam = urlParams.get('bar');
        if (barParam) {
            document.getElementById('barInput').value = barParam;
            loadBarReport();
        }

        document.getElementById('loadButton').addEventListener('click', loadBarReport);
        document.getElementById('barInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loadBarReport();
        });

        async function findLatestLogFile() {
            try {
                const response = await fetch('/api/latest-log');
                if (!response.ok) throw new Error('Cannot find latest log file');
                const data = await response.json();
                return data.path;
            } catch (error) {
                console.error('Error finding log file:', error);
                return null;
            }
        }

            async function loadStrategyParams() {
                try {
                    const response = await fetch('/api/strategy-params');
                    if (!response.ok) return null;
                    return await response.json();
                } catch (error) {
                    console.error('Error loading strategy params:', error);
                    return null;
                }
            }

        async function loadBarReport() {
            const barNumber = parseInt(document.getElementById('barInput').value);
            if (isNaN(barNumber) || barNumber < 0) {
                showError('Please enter a valid bar number (0 or greater)');
                return;
            }

            showLoading(true);
            hideError();
            document.getElementById('reportContent').style.display = 'none';

            try {
                if (!latestLogFile) {
                    latestLogFile = await findLatestLogFile();
                    if (!latestLogFile) {
                        throw new Error('No log file found. Please run the strategy first.');
                    }
                }

                    if (!strategyParams) {
                        strategyParams = await loadStrategyParams();
                    }

                const response = await fetch(`/api/bar-data?bar=${barNumber}`);
                if (!response.ok) throw new Error('Bar data not found');
                
                const barData = await response.json();
                displayBarReport(barData);
                
                showLoading(false);
                document.getElementById('reportContent').style.display = 'block';

            } catch (error) {
                showError(error.message);
                showLoading(false);
            }
        }

        function displayBarReport(bar) {
            // Update basic info
            document.getElementById('barIndex').textContent = bar.bar;
            document.getElementById('timestamp').textContent = bar.timestamp;
            
            const direction = bar.direction || 'FLAT';
            const positionBadge = `<span class="position-badge position-${direction.toLowerCase()}">${direction}</span>`;
            document.getElementById('position').innerHTML = positionBadge;
            
            document.getElementById('action').textContent = bar.action || 'BAR';
            document.getElementById('ohlc').textContent = `O: ${bar.openFinal} H: ${bar.highFinal} L: ${bar.lowFinal} C: ${bar.closeFinal}`;
            document.getElementById('candleType').textContent = (bar.candleType || 'unknown').toUpperCase();
            document.getElementById('fastEma').textContent = bar.fastEma || 'N/A';
            document.getElementById('emaGrad').textContent = bar.fastEmaGradDeg ? `${bar.fastEmaGradDeg}¬∞` : 'N/A';
            document.getElementById('volume').textContent = bar.volume || 'N/A';

            // Build conditions
            const container = document.getElementById('conditionsContainer');
            container.innerHTML = '';

            // Determine bar state
            const isEntry = bar.action === 'ENTRY';
            const isExit = bar.action === 'EXIT';
            const isInTrade = bar.direction !== 'FLAT' && !isExit;
            const isFlat = bar.direction === 'FLAT' && !isEntry;

            // Get trend detection settings (new flexible system)
            const trendLookbackBars = strategyParams?.TrendLookbackBars || 5;
            const minConsecutiveBars = strategyParams?.MinMatchingBars || 4;
            const usePnlTiebreaker = strategyParams?.UsePnLTiebreaker || false;
            
            // Build trend explanation text based on new system
            let trendUpText = '';
            let trendDownText = '';
            
            if (usePnlTiebreaker) {
                trendUpText = `Trend Up = ${bar.trendUpAtDecision} (Analyzes ${trendLookbackBars} bars, requires ${minConsecutiveBars} good OR ${minConsecutiveBars-1} good + positive PnL)`;
                trendDownText = `Trend Down = ${bar.trendDownAtDecision} (Analyzes ${trendLookbackBars} bars, requires ${minConsecutiveBars} bad OR ${minConsecutiveBars-1} bad + negative PnL)`;
            } else {
                trendUpText = `Trend Up = ${bar.trendUpAtDecision} (Analyzes ${trendLookbackBars} bars, requires ${minConsecutiveBars} good - PnL tiebreaker disabled)`;
                trendDownText = `Trend Down = ${bar.trendDownAtDecision} (Analyzes ${trendLookbackBars} bars, requires ${minConsecutiveBars} bad - PnL tiebreaker disabled)`;
            }

            // Trend State Section
            addConditionSection(container, 'Trend State', [
                {
                    label: 'Trend Up',
                    met: bar.trendUpAtDecision,
                        text: trendUpText
                },
                {
                    label: 'Trend Down',
                    met: bar.trendDownAtDecision,
                        text: trendDownText
                }
            ]);

            // Entry Filters Section
            addConditionSection(container, 'Entry Filters', [
                {
                    label: 'Allow Long This Bar',
                    met: bar.allowLongThisBar,
                    text: `Allow Long = ${bar.allowLongThisBar} (Not blocked by AvoidLongsOnBadCandle)`
                },
                {
                    label: 'Allow Short This Bar',
                    met: bar.allowShortThisBar,
                    text: `Allow Short = ${bar.allowShortThisBar} (Not blocked by AvoidShortsOnGoodCandle)`
                },
                {
                    label: 'Previous Bar Type',
                    met: bar.prevCandleType === 'good',
                    text: bar.prevOpen && bar.prevClose 
                        ? `Previous Bar = ${bar.prevCandleType.toUpperCase()} (O: ${bar.prevOpen} C: ${bar.prevClose})`
                        : `Previous Bar = ${bar.prevCandleType ? bar.prevCandleType.toUpperCase() : 'N/A'} (OHLC not logged for BAR snapshots)`,
                    neutral: bar.prevCandleType === 'good_and_bad' || !bar.prevCandleType
                }
            ]);

            // Gradient Filter Section (if enabled)
            if (bar.fastEmaGradDeg) {
                const gradDeg = parseFloat(bar.fastEmaGradDeg);
                addConditionSection(container, 'Gradient Filter (if enabled)', [
                    {
                        label: 'Gradient Value',
                        met: true,
                        text: `EMA Gradient = ${gradDeg.toFixed(2)}¬∞`,
                        neutral: true
                    },
                    {
                        label: 'Long Gradient OK',
                        met: gradDeg >= 7.0,
                        text: `Gradient ${gradDeg.toFixed(2)}¬∞ >= 7.0¬∞ (SkipLongsBelowGradient threshold)`
                    },
                    {
                        label: 'Short Gradient OK',
                        met: gradDeg <= -7.0,
                        text: `Gradient ${gradDeg.toFixed(2)}¬∞ <= -7.0¬∞ (SkipShortsAboveGradient threshold)`
                    }
                ]);
            }

            // Pending Conditions Section
            if (bar.pendingShortFromGood || bar.pendingLongFromBad) {
                addConditionSection(container, 'Pending Deferred Entries', [
                    {
                        label: 'Pending Short From Good',
                        met: bar.pendingShortFromGood,
                        text: `Pending Short = ${bar.pendingShortFromGood} (Short was deferred because trigger bar was good)`,
                        neutral: true
                    },
                    {
                        label: 'Pending Long From Bad',
                        met: bar.pendingLongFromBad,
                        text: `Pending Long = ${bar.pendingLongFromBad} (Long was deferred because trigger bar was bad)`,
                        neutral: true
                    }
                ]);
            }

            // Entry Conditions (if this is an entry bar)
            if (isEntry) {
                const isLongEntry = bar.reason === 'TrendUp';
                const isShortEntry = bar.reason === 'TrendDown';

                if (isLongEntry) {
                    addConditionSection(container, '‚úÖ LONG ENTRY CONDITIONS MET', [
                        {
                            label: 'Trend Up Active',
                            met: bar.trendUpAtDecision,
                            text: `Trend Up = TRUE`
                        },
                        {
                            label: 'Long Allowed',
                            met: bar.allowLongThisBar,
                            text: `Allow Long = TRUE`
                        },
                        {
                            label: 'Was Flat',
                            met: true,
                            text: `Previous position = FLAT (ready for entry)`
                        }
                    ]);
                } else if (isShortEntry) {
                    addConditionSection(container, '‚úÖ SHORT ENTRY CONDITIONS MET', [
                        {
                            label: 'Trend Down Active',
                            met: bar.trendDownAtDecision,
                            text: `Trend Down = TRUE`
                        },
                        {
                            label: 'Short Allowed',
                            met: bar.allowShortThisBar,
                            text: `Allow Short = TRUE`
                        },
                        {
                            label: 'Was Flat',
                            met: true,
                            text: `Previous position = FLAT (ready for entry)`
                        }
                    ]);
                }
            }

            // Exit Conditions (if this is an exit bar)
            if (isExit) {
                const exitReason = bar.reason;
                let exitConditions = [];

                if (exitReason === 'TrendBreak') {
                    exitConditions = [
                        {
                            label: 'Trend Broke',
                            met: true,
                            text: `Trend no longer met (trendUp=${bar.trendUpAtDecision}, trendDown=${bar.trendDownAtDecision})`
                        },
                        {
                            label: 'ExitOnTrendBreak Enabled',
                            met: true,
                            text: `ExitOnTrendBreak setting = TRUE`
                        }
                    ];
                } else if (exitReason === 'Retrace') {
                    exitConditions = [
                        {
                            label: 'Profit Retraced',
                            met: true,
                            text: `Profit gave back >= 66% of MFE (Max Favorable Excursion)`
                        },
                        {
                            label: 'ExitOnRetrace Enabled',
                            met: true,
                            text: `ExitOnRetrace setting = TRUE`
                        }
                    ];
                } else if (exitReason === 'EntryBarOpposite') {
                    exitConditions = [
                        {
                            label: 'Entry Bar Closed Opposite',
                            met: true,
                            text: `Entry bar closed opposite to position direction`
                        },
                        {
                            label: 'ExitIfEntryBarOpposite Enabled',
                            met: true,
                            text: `ExitIfEntryBarOpposite setting = TRUE`
                        }
                    ];
                }

                if (exitConditions.length > 0) {
                    addConditionSection(container, `‚ùå EXIT CONDITIONS MET (${exitReason})`, exitConditions);
                }
            }

            // In-Trade Conditions (if currently in a position)
            if (isInTrade) {
                const isLong = bar.direction === 'LONG';
                const conditions = [
                    {
                        label: 'Position Active',
                        met: true,
                        text: `Currently ${bar.direction} (entry at bar ${bar.decisionBarIndex})`
                    },
                    {
                        label: 'Trend Still Valid',
                        met: isLong ? bar.trendUpAtDecision : bar.trendDownAtDecision,
                        text: `Trend ${isLong ? 'Up' : 'Down'} = ${isLong ? bar.trendUpAtDecision : bar.trendDownAtDecision}`
                    }
                ];

                addConditionSection(container, 'üìä IN-TRADE STATUS', conditions);
            }

            // Flat Conditions (no position, no entry)
            if (isFlat) {
                const longBlocked = !bar.trendUpAtDecision || !bar.allowLongThisBar;
                const shortBlocked = !bar.trendDownAtDecision || !bar.allowShortThisBar;
                
                let whyNoEntry = [];
                if (longBlocked && shortBlocked) {
                    whyNoEntry.push('Both Long and Short entries blocked');
                } else if (longBlocked) {
                    whyNoEntry.push('Long entry blocked');
                } else if (shortBlocked) {
                    whyNoEntry.push('Short entry blocked');
                }
                
                if (!bar.trendUpAtDecision && !bar.trendDownAtDecision) {
                    whyNoEntry.push(`No trend detected (analyzes ${trendLookbackBars} bars, requires ${minConsecutiveBars} matching - see TrendLookbackBars/MinConsecutiveBars)`);
                }
                
                const conditions = [
                    {
                        label: 'Trend Up',
                        met: bar.trendUpAtDecision,
                        text: `Trend Up = ${bar.trendUpAtDecision} ${!bar.trendUpAtDecision ? '‚ùå BLOCKING LONG' : '‚úÖ ALLOWS LONG'}`
                    },
                    {
                        label: 'Trend Down',
                        met: bar.trendDownAtDecision,
                        text: `Trend Down = ${bar.trendDownAtDecision} ${!bar.trendDownAtDecision ? '‚ùå BLOCKING SHORT' : '‚úÖ ALLOWS SHORT'}`
                    },
                    {
                        label: 'Allow Long',
                        met: bar.allowLongThisBar,
                        text: `Allow Long = ${bar.allowLongThisBar} ${!bar.allowLongThisBar ? '‚ùå BLOCKED by AvoidLongsOnBadCandle' : '‚úÖ Not blocked'}`
                    },
                    {
                        label: 'Allow Short',
                        met: bar.allowShortThisBar,
                        text: `Allow Short = ${bar.allowShortThisBar} ${!bar.allowShortThisBar ? '‚ùå BLOCKED by AvoidShortsOnGoodCandle' : '‚úÖ Not blocked'}`
                    }
                ];
                
                // Add gradient filter info if available
                if (bar.fastEmaGradDeg) {
                    const gradDeg = parseFloat(bar.fastEmaGradDeg);
                    const longGradOk = gradDeg >= 7.0;
                    const shortGradOk = gradDeg <= -7.0;
                    
                    if (!longGradOk) {
                        whyNoEntry.push(`Long: EMA gradient ${gradDeg.toFixed(2)}¬∞ < 7.0¬∞ (too flat/down)`);
                    }
                    if (!shortGradOk) {
                        whyNoEntry.push(`Short: EMA gradient ${gradDeg.toFixed(2)}¬∞ > -7.0¬∞ (too flat/up)`);
                    }
                    
                    conditions.push({
                        label: 'Long Gradient Check (if GradientFilterEnabled)',
                        met: longGradOk,
                        text: `EMA Gradient ${gradDeg.toFixed(2)}¬∞ ${longGradOk ? '‚â•' : '<'} 7.0¬∞ ${!longGradOk ? '‚ùå Would BLOCK LONG if filter enabled' : '‚úÖ Would allow long'}`
                    });
                    conditions.push({
                        label: 'Short Gradient Check (if GradientFilterEnabled)',
                        met: shortGradOk,
                        text: `EMA Gradient ${gradDeg.toFixed(2)}¬∞ ${shortGradOk ? '‚â§' : '>'} -7.0¬∞ ${!shortGradOk ? '‚ùå Would BLOCK SHORT if filter enabled' : '‚úÖ Would allow short'}`
                    });
                }
                
                const summaryText = whyNoEntry.length > 0 ? whyNoEntry.join('; ') : 'No blocking conditions found';
                addConditionSection(container, `‚è∏Ô∏è FLAT - WHY NO ENTRY: ${summaryText}`, conditions);
            }
        }

        function addConditionSection(container, title, conditions) {
            const section = document.createElement('div');
            section.className = 'conditions-section';
            
            const heading = document.createElement('h3');
            heading.textContent = title;
            section.appendChild(heading);

            conditions.forEach(cond => {
                const condDiv = document.createElement('div');
                if (cond.neutral) {
                    condDiv.className = 'condition neutral';
                } else {
                    condDiv.className = `condition ${cond.met ? 'met' : 'not-met'}`;
                }

                const icon = document.createElement('span');
                icon.className = 'condition-icon';
                icon.textContent = cond.neutral ? '‚ö†Ô∏è' : (cond.met ? '‚úÖ' : '‚ùå');
                condDiv.appendChild(icon);

                const text = document.createElement('div');
                text.className = 'condition-text';
                text.innerHTML = `<span class="condition-label">${cond.label}:</span> ${cond.text}`;
                condDiv.appendChild(text);

                section.appendChild(condDiv);
            });

            container.appendChild(section);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMsg');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMsg').style.display = 'none';
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
    </script>
</body>
</html>
