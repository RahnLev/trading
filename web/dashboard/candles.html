<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candle Chart - Strategy Logs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #1a1f3a 0%, #2d3561 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        input[type="file"] {
            padding: 8px;
            background: #1a1f3a;
            border: 1px solid #374151;
            border-radius: 5px;
            color: #e0e0e0;
            cursor: pointer;
        }

        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: #2563eb;
        }

        .stats {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-card {
            background: #1a1f3a;
            padding: 12px 16px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            min-width: 120px;
        }

        .stat-label {
            font-size: 11px;
            color: #9ca3af;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #60a5fa;
        }

        .chart-container {
            background: #1a1f3a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            overflow-x: auto;
            position: relative;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .tooltip {
            position: absolute;
            background: rgba(26, 31, 58, 0.95);
            border: 1px solid #60a5fa;
            border-radius: 5px;
            padding: 10px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            font-size: 12px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tooltip.show {
            display: block;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-bottom: 3px;
        }

        .tooltip-label {
            color: #9ca3af;
        }

        .tooltip-value {
            color: #e0e0e0;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #9ca3af;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #fca5a5;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-size: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .long-entry { background: #10b981; }
        .short-entry { background: #ef4444; }
        .exit { background: #f59e0b; }

        /* Pattern Analysis Styles */
        .analysis-controls input[type="checkbox"] {
            margin-right: 5px;
            transform: scale(1.2);
        }

        .analysis-controls label {
            color: #e0e0e0;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
        }

        .analysis-controls label:hover {
            color: #60a5fa;
        }

        .analysis-group {
            padding: 10px;
            background: rgba(31, 41, 55, 0.6);
            border-radius: 6px;
        }

        .pattern-marker {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        .trend-line {
            stroke: #60a5fa;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            opacity: 0.8;
        }

        .support-line {
            stroke: #10b981;
            stroke-width: 2;
            opacity: 0.7;
        }

        .resistance-line {
            stroke: #ef4444;
            stroke-width: 2;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìä Candle Chart from Strategy Logs</h1>
        <p>Upload a CSV file from strategy_logs to visualize price action and trades</p>
        
        <div class="controls">
            <input type="file" id="fileInput" accept=".csv" />
            <button onclick="loadFromServer()">Load Latest from Server</button>
                <button id="liveToggle" onclick="toggleLiveFeed()" style="background: #2563eb;">Go Live</button>
            <span id="status" style="color: #9ca3af; font-size: 12px;"></span>
                <span id="liveStatus" style="color: #9ca3af; font-size: 12px;">Live: disconnected</span>
            <button id="downloadTrendLogBtn" onclick="downloadTrendLogCsv()" style="background:#6b7280;">Download Trend CSV</button>
            <button id="saveTrendLogBtn" onclick="saveTrendLogToServer()" style="background:#4b5563;">Save Trend CSV (server)</button>
            <span id="trendLogStatus" style="color:#9ca3af; font-size:12px;">Trend log: 0</span>
            <label style="display: inline-flex; align-items: center; gap: 6px; color: #9ca3af; font-size: 12px; margin-left: 8px;">
                    <span>Trend start after</span>
                    <input id="minLoggedBarsInput" type="number" min="1" max="10" step="1" value="5" style="width: 56px; background: #1f2937; color: #e5e7eb; border: 1px solid #374151; border-radius: 4px; padding: 4px 6px;" />
                    <span>bars</span>
                </label>
            <label style="display: inline-flex; align-items: center; gap: 6px; color: #9ca3af; font-size: 12px; margin-left: 8px;">
                <span>Min bars for trend</span>
                <input id="minTrendBarsInput" type="number" min="1" max="50" step="1" value="" placeholder="auto" style="width: 72px; background: #1f2937; color: #e5e7eb; border: 1px solid #374151; border-radius: 4px; padding: 4px 6px;" />
            </label>
            <label style="display: inline-flex; align-items: center; gap: 6px; color: #9ca3af; font-size: 12px; margin-left: 8px;">
                <input type="checkbox" id="enableFlipLogging"> Log trend flips
            </label>
            <button id="autoSendToggle" onclick="toggleAutoSendTrends()" style="background: #f97316;">Auto Send Trends: Off</button>
            <button onclick="sendManualTrend('UP')" style="background:#10b981;">Send Long Trend</button>
            <button onclick="sendManualTrend('FLAT')" style="background:#6b7280;">Send Flat Trend</button>
            <button onclick="sendManualTrend('DOWN')" style="background:#ef4444;">Send Short Trend</button>
        </div>

        <div id="flipLogContainer" style="margin-top: 8px; background: rgba(31, 41, 55, 0.7); border: 1px solid #374151; border-radius: 6px; padding: 8px; max-width: 800px;">
            <div style="display: flex; align-items: center; justify-content: space-between; color: #9ca3af; font-size: 12px;">
                <span>Trend flip log (last 50)</span>
                <span id="flipLogStatus" style="color: #6b7280;">logging off</span>
            </div>
            <div id="flipLogList" style="margin-top: 6px; max-height: 120px; overflow-y: auto; font-family: monospace; font-size: 12px; color: #e5e7eb; white-space: nowrap;">
                No flips yet
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: #10b981; border: 2px solid #10b981;"></div>
                <span>Bullish Candle</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #ef4444; border: 2px solid #ef4444;"></div>
                <span>Bearish Candle</span>
            </div>
            <div class="legend-item">
                <div class="legend-box long-entry"></div>
                <span>LONG Entry</span>
            </div>
            <div class="legend-item">
                <div class="legend-box short-entry"></div>
                <span>SHORT Entry</span>
            </div>
            <div class="legend-item">
                <div class="legend-box exit"></div>
                <span>Exit</span>
            </div>
        </div>

        <!-- Pattern Analysis Controls -->
        <div class="analysis-controls" style="margin-top: 15px; padding: 15px; background: rgba(26, 31, 58, 0.8); border-radius: 8px;">
            <h3 style="color: #60a5fa; margin-bottom: 10px;">üìà Pattern Analysis</h3>
            <div style="margin-bottom: 15px; text-align: center;">
                <button id="selectAll" style="margin-right: 10px; padding: 6px 12px; font-size: 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">Select All</button>
                <button id="selectNone" style="padding: 6px 12px; font-size: 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Select None</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                <!-- Trend Detection -->
                <div class="analysis-group">
                    <label style="color: #10b981; font-weight: bold;">üîç Trend Detection</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableTrendDetection"> Enable Trend Lines</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableCandidateTrends" checked> Candidate Trend Overlay</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableSupportResistance"> Support/Resistance</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableBreakouts"> Breakout Detection</label>
                </div>

                <!-- Candlestick Patterns -->
                <div class="analysis-group">
                    <label style="color: #f59e0b; font-weight: bold;">üïØÔ∏è Candlestick Patterns</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableEngulfing"> Engulfing Patterns</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableDoji"> Doji Patterns</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableHammer"> Hammer/Shooting Star</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableThreeSoldiers"> Three Soldiers/Crows</label>
                </div>

                <!-- Volume & Momentum -->
                <div class="analysis-group">
                    <label style="color: #8b5cf6; font-weight: bold;">üìä Volume & Momentum</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableVolumeSpikes"> Volume Spikes</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableMomentumDivergence"> Price Divergence</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableMovingAverages"> Moving Averages</label>
                </div>
            </div>

            <div style="display: flex; gap: 10px; align-items: center;">
                <button onclick="runPatternAnalysis()" style="background: #10b981;">üîç Analyze Patterns</button>
                <button onclick="clearPatternOverlays()" style="background: #6b7280;">Clear Overlays</button>
                <button onclick="downloadAnalysis()" style="background: #2563eb;">‚¨áÔ∏è Download Analysis</button>
                <button onclick="sendLatestTrendToStrategy()" style="background: #f97316;">üì° Send Latest Trend</button>
                <span id="patternStats" style="color: #9ca3af; font-size: 12px; margin-left: 10px;"></span>
            </div>
        </div>
    </div>

    <div style="margin: 20px; display: flex; align-items: center; gap: 15px;">
        <label style="color: #9ca3af; font-weight: 500;">Timeframe:</label>
        <select id="timeframe" style="background: #1f2937; color: #e5e7eb; border: 1px solid #374151; padding: 8px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
            <option value="1">Raw Data (as recorded)</option>
            <option value="30">30 seconds</option>
            <option value="60">1 minute</option>
            <option value="120">2 minutes</option>
            <option value="300">5 minutes</option>
            <option value="600">10 minutes</option>
            <option value="900">15 minutes</option>
            <option value="1800">30 minutes</option>
            <option value="3600">1 hour</option>
        </select>
    </div>

    <div class="stats" id="stats" style="display: none;">
        <div class="stat-card">
            <div class="stat-label">Total Bars</div>
            <div class="stat-value" id="stat-bars">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">LONG Entries</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">SHORT Entries</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Exits</div>
            <div class="stat-value" style="color: #f59e0b;" id="stat-exits">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Price Range</div>
            <div class="stat-value" id="stat-range">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #06b6d4;">
            <div class="stat-label">Total PNL</div>
            <div class="stat-value" style="color: #06b6d4;" id="stat-total-pnl">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #10b981;">
            <div class="stat-label">LONG Trends</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long-trends">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #ef4444;">
            <div class="stat-label">SHORT Trends</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short-trends">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #4b5563;">
            <div class="stat-label">FLAT / Neutral</div>
            <div class="stat-value" style="color: #4b5563;" id="stat-neutral-trends">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #8b5cf6;">
            <div class="stat-label">Total Trends (>= bars)</div>
            <div class="stat-value" style="color: #8b5cf6;" id="stat-total-patterns">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #10b981;">
            <div class="stat-label">LONG (>= bars)</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long-patterns">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #ef4444;">
            <div class="stat-label">SHORT (>= bars)</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short-patterns">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #f59e0b;">
            <div class="stat-label">FLAT (>= bars)</div>
            <div class="stat-value" style="color: #f59e0b;" id="stat-flat-patterns">0</div>
        </div>
    </div>

    <div class="chart-container">
        <canvas id="chartCanvas"></canvas>
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        let rawCandles = []; // Original data
        let rawEntries = [];
        let rawExits = [];
        let candles = []; // Aggregated data for display
        let entries = [];
        let exits = [];
        let trends = [];
        let candidateTrends = [];
        let ctx, tooltip;
        let priceZoom = 1.0; // Vertical zoom factor for price axis
        let priceOffset = 0; // Vertical pan offset (in price units)
        let timeZoom = 1.0; // Horizontal zoom factor for candle spacing
        let isDragging = false;
        let isTimeZoomDrag = false;
        let dragStartY = 0;
        let dragStartX = 0;
        let candleOffset = 0; // Horizontal scroll offset (in candles)
        let chartPadding = { top: 40, right: 80, bottom: 40, left: 80 };

        // Pattern Analysis Variables
        let detectedPatterns = [];
        let trendLines = [];
        let supportResistanceLevels = [];
        let patternDirections = { LONG: 0, SHORT: 0, FLAT: 0 };
        let patternOverlaysEnabled = false;
        let lastHoverIndex = null; // track last hovered candle for quick copy
        let liveBarMap = new Map(); // barIndex -> candle for live mode
        let liveSocket = null;
        let liveDrawPending = null;
        let autoSendTrends = false;
        let logTrendFlips = false;
        let flipLogEntries = [];
        let lastSentTrendKey = null;
        let lastOverlayCommandKey = null; // avoid duplicate overlay-driven sends
        let lastOverlayDirection = null;   // track overlay direction to avoid spamming same side
        let lastOverlayStartIdx = null;
        let liveTrendLog = []; // in-memory CSV rows while live feed runs
        let liveLoggingActive = false;
        let lastLoggedTrendKey = null;
        let lastLoggedTrendObj = null;
        let minLoggedBarsSetting = 5; // default bars required before START/overlay fire
        let minTrendBarsSetting = null; // optional override for minimum bars to accept a trend

        // Derive a candle type from payload hints or price direction
        function deriveCandleType(candle, payload = {}) {
            const fromPayload = payload?.signal ?? payload?.trendSide ?? payload?.candleType ?? payload?.CandleType ??
                payload?.type ?? payload?.Type ?? payload?.trend ?? payload?.Trend ?? payload?.direction ?? payload?.Direction ??
                payload?.side ?? payload?.Side ?? payload?.position ?? payload?.Position ?? '';

            const trimmed = typeof fromPayload === 'string'
                ? fromPayload.trim()
                : (fromPayload != null ? String(fromPayload).trim() : '');

            if (trimmed) return trimmed;

            if (candle && Number.isFinite(candle.close) && Number.isFinite(candle.open)) {
                if (candle.close > candle.open) return 'good';   // bullish
                if (candle.close < candle.open) return 'bad';    // bearish
                return 'flat';
            }

            return '';
        }

        // Trend Analysis Functions (duplicate removed)
        
        function calculateLinearRegression(values) {
            const n = values.length;
            const x = Array.from({length: n}, (_, i) => i);
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        function calculateTrendStrength(startIdx, endIdx) {
            const length = endIdx - startIdx + 1;
            const priceStart = candles[startIdx].close;
            const priceEnd = candles[endIdx].close;
            const priceChange = Math.abs(priceEnd - priceStart) / priceStart;
            
            // Strength based on price change magnitude and trend length
            return Math.min(priceChange * 100 + length / 10, 10);
        }

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('timeframe').addEventListener('change', function() {
            if (rawCandles.length > 0) {
                aggregateCandles();
                generateRealTrends();
                updateStats();
                drawChart();
            }
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('status').textContent = 'Reading file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parseCSV(e.target.result);
                    document.getElementById('status').textContent = `Loaded: ${file.name}`;
                } catch (error) {
                    document.getElementById('status').innerHTML = `<span style="color: #ef4444;">Error: ${error.message}</span>`;
                }
            };
            reader.readAsText(file);
        }

        async function loadFromServer() {
            document.getElementById('status').textContent = 'Loading from server...';
            try {
                // Try to get latest CSV from server
                const response = await fetch('/logs/latest-csv');
                if (response.status === 404) {
                    document.getElementById('status').textContent = 'No server CSV (404)';
                    return;
                }
                if (!response.ok) throw new Error(`Server returned ${response.status}`);
                
                const csvText = await response.text();
                const filename = response.headers.get('X-Log-Filename') || 'latest csv';
                parseCSV(csvText);
                document.getElementById('status').textContent = `Loaded from server: ${filename}`;
            } catch (error) {
                document.getElementById('status').innerHTML = `<span style="color: #ef4444;">Error: ${error.message}</span>`;
            }
        }

        async function preloadRecentBars() {
            const statusEl = document.getElementById('status');
            if (statusEl && rawCandles.length === 0) {
                statusEl.textContent = 'Preloading recent bars...';
            }

            try {
                const res = await fetch('/bars/latest?limit=1200');
                if (res.status === 404) {
                    if (statusEl && rawCandles.length === 0) {
                        statusEl.textContent = 'No cached bars (404)';
                    }
                    return;
                }
                if (!res.ok) throw new Error(`Server returned ${res.status}`);

                const json = await res.json();
                const bars = Array.isArray(json.bars) ? json.bars : [];
                if (bars.length === 0) {
                    if (statusEl && rawCandles.length === 0) {
                        statusEl.textContent = 'No cached bars available';
                    }
                    return;
                }

                liveBarMap.clear();
                bars.forEach(b => {
                    const barIndex = Number(b.barIndex ?? b.BarIndex);
                    if (!Number.isFinite(barIndex)) return;

                    const open = Number(b.open ?? b.Open ?? b.close ?? b.Close ?? 0);
                    const close = Number(b.close ?? b.Close ?? open);
                    const high = Number(b.high ?? b.High ?? Math.max(open, close));
                    const low = Number(b.low ?? b.Low ?? Math.min(open, close));
                    const ts = b.localTime || b.time || (b.ts ? new Date(b.ts * 1000).toISOString() : new Date().toISOString());

                    liveBarMap.set(barIndex, {
                        bar: barIndex,
                        timestamp: ts,
                        open,
                        high,
                        low,
                        close,
                        candleType: deriveCandleType({ open, close }, b)
                    });
                });

                const merged = Array.from(liveBarMap.values()).sort((a, b) => a.bar - b.bar);
                rawCandles = merged;
                aggregateCandles();
                generateRealTrends();
                updateStats();
                drawChart();

                if (statusEl) {
                    statusEl.textContent = `Preloaded ${rawCandles.length} cached bars`;
                }
            } catch (err) {
                console.warn('Preload recent bars failed', err);
                if (statusEl && rawCandles.length === 0) {
                    statusEl.textContent = `Preload failed: ${err.message || err}`;
                }
            }
        }

        function parseCSV(csvText) {
            // Reset previously loaded data so uploads don't accumulate
            rawCandles = [];
            rawEntries = [];
            rawExits = [];
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) throw new Error('CSV file is empty or invalid');

            // Parse header (case-insensitive so PNL/candle columns don't get lost)
            const header = lines[0].split(',').map(h => h.trim());
            const lowerHeader = header.map(h => h.toLowerCase());
            const barCol = lowerHeader.indexOf('bar');
            const timestampCol = lowerHeader.indexOf('timestamp');

            // Find OHLC columns (they might have different names)
            const openCol = lowerHeader.findIndex(h => h.includes('open'));
            const highCol = lowerHeader.findIndex(h => h.includes('high'));
            const lowCol = lowerHeader.findIndex(h => h.includes('low'));
            const closeCol = lowerHeader.findIndex(h => h.includes('close'));
            const pnlCol = lowerHeader.findIndex(h => h === 'pnl' || h === 'pl' || h.includes('pnl'));
            let candleTypeCol = lowerHeader.findIndex(h => h === 'candletype' || h.includes('candle'));
            if (candleTypeCol === -1) {
                // Fallback: grab a generic "type" column that's not already matched to known fields
                const reserved = new Set([barCol, timestampCol, openCol, highCol, lowCol, closeCol, pnlCol]);
                candleTypeCol = lowerHeader.findIndex((h, idx) => h.includes('type') && !reserved.has(idx));
            }

            candles = [];
            entries = [];
            exits = [];
            const candleByBar = new Map();

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const cols = line.split(',').map(c => c.trim());
                
                const bar = parseInt(cols[barCol]) || i;
                const timestamp = cols[timestampCol] || '';

                // Extract OHLC if available
                const open = parseFloat(cols[openCol]) || null;
                const high = parseFloat(cols[highCol]) || null;
                const low = parseFloat(cols[lowCol]) || null;
                const close = parseFloat(cols[closeCol]) || null;
                const pnlRaw = pnlCol >= 0 ? parseFloat(cols[pnlCol]) : NaN;
                const pnl = Number.isFinite(pnlRaw)
                    ? pnlRaw
                    : (Number.isFinite(close) && Number.isFinite(open) ? close - open : null);
                const candleType = candleTypeCol >= 0 ? cols[candleTypeCol] || '' : '';

                // Store candle data if we have price info
                if (open !== null && high !== null && low !== null && close !== null) {
                    candleByBar.set(bar, { bar, timestamp, open, high, low, close, pnl, candleType });
                }
            }

            rawCandles = Array.from(candleByBar.values())
                .map(c => ({ bar: c.bar, timestamp: c.timestamp, open: c.open, high: c.high, low: c.low, close: c.close, pnl: c.pnl, candleType: c.candleType }))
                .sort((a, b) => a.bar - b.bar);

            if (rawCandles.length === 0) {
                throw new Error('No valid candle data found in CSV. Make sure the file has Open, High, Low, Close columns.');
            }

            // Initial aggregation
            aggregateCandles();

            // Generate real trends based on market analysis
            generateRealTrends();

            updateStats();
            drawChart();
        }

        // =============================================
        // LIVE STREAMING (WebSocket) BRIDGE
        // =============================================
        function updateLiveStatus(text, color = '#9ca3af') {
            const el = document.getElementById('liveStatus');
            if (el) {
                el.textContent = `Live: ${text}`;
                el.style.color = color;
            }
        }

        function toggleLiveFeed() {
            if (liveSocket) {
                disconnectLiveFeed();
            } else {
                connectLiveFeed();
            }
        }

        function connectLiveFeed() {
            try {
                const proto = location.protocol === 'https:' ? 'wss' : 'ws';
                const host = (location.host && location.host.trim()) ? location.host : '127.0.0.1:51888';
                const url = `${proto}://${host}/ws`;
                liveSocket = new WebSocket(url);
                resetLiveTrendLog();
                document.getElementById('liveToggle').textContent = 'Stop Live';
                updateLiveStatus(`connecting to ${host}...`, '#f59e0b');

                liveSocket.onopen = () => {
                    updateLiveStatus('connected', '#10b981');
                };

                liveSocket.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        if (msg.type === 'diag' && msg.data) {
                            handleLiveDiag(msg.data);
                        }
                    } catch (err) {
                        console.warn('Live message parse error', err);
                    }
                };

                liveSocket.onclose = (evt) => {
                    liveSocket = null;
                    document.getElementById('liveToggle').textContent = 'Go Live';
                    const reason = evt && evt.code ? `disconnected (code ${evt.code})` : 'disconnected';
                    updateLiveStatus(reason);
                };

                liveSocket.onerror = (evt) => {
                    console.error('Live WS error', evt);
                    updateLiveStatus('error', '#ef4444');
                };
            } catch (err) {
                liveSocket = null;
                document.getElementById('liveToggle').textContent = 'Go Live';
                updateLiveStatus('error starting live', '#ef4444');
                console.error('Live connect error', err);
            }
        }

        function disconnectLiveFeed() {
            if (liveSocket) {
                try { liveSocket.close(); } catch (e) {}
            }
            liveSocket = null;
            document.getElementById('liveToggle').textContent = 'Go Live';
            if (liveLoggingActive && lastLoggedTrendObj) {
                appendTrendLog('END', lastLoggedTrendObj);
            }
            updateLiveStatus('disconnected');
            liveLoggingActive = false;
            updateTrendLogStatus();
        }

        function handleLiveDiag(payload) {
            const barIndex = Number(payload.barIndex ?? payload.BarIndex);
            if (!Number.isFinite(barIndex)) return;

            const open = Number(payload.open ?? payload.Open ?? payload.close ?? payload.Close ?? 0);
            const high = Number(payload.high ?? payload.High ?? open);
            const low = Number(payload.low ?? payload.Low ?? open);
            const close = Number(payload.close ?? payload.Close ?? open);
            const pnlRaw = Number(payload.pnl ?? payload.PNL ?? payload.pl ?? payload.PL);
            const pnl = Number.isFinite(pnlRaw) ? pnlRaw : (close - open);
            const ts = payload.time || payload.localTime || new Date().toISOString();

            const candle = {
                bar: barIndex,
                timestamp: ts,
                open,
                high,
                low,
                close,
                pnl,
                candleType: deriveCandleType({ open, close }, payload)
            };

            liveBarMap.set(barIndex, candle);
            // Trim if we exceed max cache
            if (liveBarMap.size > 800) {
                const oldest = Math.min(...liveBarMap.keys());
                liveBarMap.delete(oldest);
            }

            scheduleLiveRedraw();
        }

        function scheduleLiveRedraw() {
            if (liveDrawPending) return;
            liveDrawPending = requestAnimationFrame(() => {
                const merged = Array.from(liveBarMap.values()).sort((a, b) => a.bar - b.bar);
                rawCandles = merged;
                aggregateCandles();
                generateRealTrends();
                maybeLogTrendChange();
                sendOverlayTrendIfChanged('live-overlay');
                updateStats();
                drawChart();
                // Auto-run candidate trend analysis in live mode when enabled so overlays and auto-send fire
                if (autoSendTrends && document.getElementById('enableCandidateTrends')?.checked) {
                    runPatternAnalysis();
                    drawChart();
                }
                liveDrawPending = null;
                document.getElementById('status').textContent = `Live bars: ${rawCandles.length}`;
            });
        }

        function resetLiveTrendLog() {
            liveTrendLog = [];
            liveLoggingActive = true;
            lastLoggedTrendKey = null;
            lastLoggedTrendObj = null;
            updateTrendLogStatus();
        }

        function updateTrendLogStatus() {
            const el = document.getElementById('trendLogStatus');
            if (!el) return;
            const count = liveTrendLog.length;
            const activeText = liveLoggingActive ? 'ON' : 'OFF';
            el.textContent = `Trend log: ${count} (${activeText})`;
            el.style.color = liveLoggingActive ? '#10b981' : '#9ca3af';
        }

        function recomputeAndRedraw(reason = 'ui-change') {
            // Re-run derived data and refresh visuals when config toggles change
            // Force overlay resend on recompute by clearing last overlay state
            lastOverlayDirection = null;
            lastOverlayStartIdx = null;
            lastSentTrendKey = null;
            generateRealTrends();
            maybeLogTrendChange();
            sendOverlayTrendIfChanged(reason);
            updateStats();
            drawChart();
        }

        function initMinTrendBarsControl() {
            const input = document.getElementById('minTrendBarsInput');
            if (!input) return;
            if (Number.isFinite(minTrendBarsSetting)) {
                input.value = minTrendBarsSetting;
            }
            input.addEventListener('change', () => {
                const val = parseInt(input.value, 10);
                if (Number.isFinite(val) && val >= 1 && val <= 50) {
                    minTrendBarsSetting = val;
                } else {
                    minTrendBarsSetting = null; // fall back to auto-calculated trend length
                    input.value = '';
                }
                recomputeAndRedraw('min-trend-bars-change');
            });
        }

        function initMinLoggedBarsControl() {
            const input = document.getElementById('minLoggedBarsInput');
            if (!input) return;
            input.value = minLoggedBarsSetting;
            input.addEventListener('change', () => {
                const val = parseInt(input.value, 10);
                if (Number.isFinite(val) && val >= 1 && val <= 10) {
                    minLoggedBarsSetting = val;
                } else {
                    minLoggedBarsSetting = 2;
                    input.value = minLoggedBarsSetting;
                }
                recomputeAndRedraw('min-logged-bars-change');
            });
        }

        async function appendTrendLog(eventType, trend) {
            if (!liveLoggingActive || !trend) return;

            const startIdx = trend.startIdx ?? trend.startIndex ?? trend.index ?? 0;
            const endIdx = trend.endIdx ?? trend.endIndex ?? startIdx;
            const startBar = trend.startBar ?? candles[startIdx]?.bar ?? startIdx;
            const endBar = trend.endBar ?? candles[endIdx]?.bar ?? endIdx;

            const rawDirection = String(trend.type || trend.direction || trend.side || trend.signal || '').toUpperCase();
            const direction =
                rawDirection.includes('SHORT') || rawDirection.includes('SELL') || rawDirection.includes('DOWN') ? 'SHORT' :
                rawDirection.includes('LONG') || rawDirection.includes('BUY') || rawDirection.includes('UP') ? 'LONG' :
                rawDirection.includes('FLAT') || rawDirection.includes('NEUTRAL') ? 'FLAT' :
                'UNKNOWN';

            const startPrice = candles[startIdx]?.close ?? candles[candles.length - 1]?.close ?? null;
            const endPrice = candles[endIdx]?.close ?? candles[candles.length - 1]?.close ?? null;
            const priceChange = (Number.isFinite(endPrice) && Number.isFinite(startPrice)) ? endPrice - startPrice : null;
            const pctChange = (Number.isFinite(priceChange) && Number.isFinite(startPrice) && startPrice !== 0)
                ? (priceChange / startPrice) * 100
                : null;
            const dirSign = direction === 'LONG' ? 1 : direction === 'SHORT' ? -1 : 0;
            const signedChange = Number.isFinite(priceChange) && dirSign !== 0 ? priceChange * dirSign : null;
            const signedPct = Number.isFinite(pctChange) && dirSign !== 0 ? pctChange * dirSign : null;

            const row = {
                timestamp: new Date().toISOString(),
                event: eventType,
                direction,
                rawDirection,
                startIdx,
                endIdx,
                startBar,
                endBar,
                startPrice,
                endPrice,
                priceChange,
                pctChange,
                price: endPrice,
                signedChange,
                signedPct,
                strength: trend.strength ?? trend.change ?? null
            };

            liveTrendLog.push(row);
            updateTrendLogStatus();

            // Try to stream to server-side log writer if available
            try {
                await fetch('/logs/trend-event', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(row)
                });
            } catch (err) {
                console.warn('Trend log post failed', err);
            }

            // Secondary attempt: append CSV-style row to a dedicated trend-log file server-side
            try {
                const csvRow = [
                    row.timestamp,
                    row.event,
                    row.direction,
                    row.rawDirection,
                    startIdx,
                    endIdx,
                    startBar,
                    endBar,
                    startPrice ?? '',
                    endPrice ?? '',
                    priceChange ?? '',
                    pctChange ?? '',
                    signedChange ?? '',
                    signedPct ?? '',
                    row.strength ?? ''
                ].join(',');
                await fetch('/logs/trend-csv', {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: csvRow
                });
            } catch (err) {
                console.warn('Trend CSV post failed', err);
            }
        }

        function maybeLogTrendChange() {
            if (!liveLoggingActive) return;

            // Require a minimum number of bars before logging a trend to avoid noisy flapping
            const minLoggedBars = Math.max(1, Number(minLoggedBarsSetting) || 2);

            if (!trends || trends.length === 0) {
                if (lastLoggedTrendKey && lastLoggedTrendObj) {
                    appendTrendLog('END', lastLoggedTrendObj);
                }
                lastLoggedTrendKey = null;
                lastLoggedTrendObj = null;
                return;
            }

            const lastTrend = trends[trends.length - 1];
            const startIdx = lastTrend.startIdx ?? lastTrend.startIndex ?? lastTrend.index ?? 0;
            const endIdx = lastTrend.endIdx ?? lastTrend.endIndex ?? startIdx;
            const trendLength = endIdx - startIdx + 1;

            // Key only on direction + start so extending the same trend does not relog START/END
            const key = `${lastTrend.type}:${startIdx}`;

            // If we switched to a new trend (direction or start changed), close the prior one
            if (lastLoggedTrendKey && lastLoggedTrendKey !== key && lastLoggedTrendObj) {
                appendTrendLog('END', lastLoggedTrendObj);
            }

            // Only log a START once the trend has enough bars
            if (lastLoggedTrendKey !== key && trendLength >= minLoggedBars) {
                appendTrendLog('START', lastTrend);
                lastLoggedTrendKey = key;
                lastLoggedTrendObj = lastTrend;
                return;
            }

            // Update reference so we can END it when direction changes
            if (lastLoggedTrendKey === key) {
                lastLoggedTrendObj = lastTrend;
            }
        }

        function downloadTrendLogCsv() {
            if (!liveTrendLog || liveTrendLog.length === 0) {
                alert('No trend log rows yet');
                return;
            }

            const header = ['timestamp','event','direction','rawDirection','startIdx','endIdx','startBar','endBar','startPrice','endPrice','priceChange','pctChange','signedChange','signedPct','strength'];
            const rows = liveTrendLog.map(r => header.map(h => r[h] ?? '').join(','));
            const csv = [header.join(','), ...rows].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'trend-log.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function saveTrendLogToServer() {
            if (!liveTrendLog || liveTrendLog.length === 0) {
                alert('No trend log rows yet');
                return;
            }

            const header = ['timestamp','event','direction','rawDirection','startIdx','endIdx','startBar','endBar','startPrice','endPrice','priceChange','pctChange','signedChange','signedPct','strength'];
            const rows = liveTrendLog.map(r => header.map(h => r[h] ?? '').join(','));
            const csv = [header.join(','), ...rows].join('\n');

            try {
                const res = await fetch('/logs/save-trend-csv', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: 'trend-log.csv', csv })
                });
                if (!res.ok) {
                    const txt = await res.text();
                    alert(`Server save failed: ${txt || res.status}`);
                } else {
                    updateLiveStatus('trend-log.csv saved to server', '#10b981');
                }
            } catch (err) {
                alert('Could not save trend log to server');
                console.warn('saveTrendLogToServer failed', err);
            }
        }

        function aggregateCandles() {
            const timeframeSeconds = parseInt(document.getElementById('timeframe').value);
            
            if (timeframeSeconds === 1) {
                // No aggregation - use raw data
                candles = [...rawCandles].sort((a, b) => a.bar - b.bar);
                entries = [...rawEntries];
                exits = [...rawExits];
                return;
            }

            // Parse timestamps and group by timeframe
            candles = [];
            const candleMap = new Map();

            rawCandles.forEach(candle => {
                // Parse timestamp - format: MM/dd/yyyy HH:mm:ss
                const date = new Date(candle.timestamp);
                if (isNaN(date.getTime())) {
                    console.warn('Invalid timestamp:', candle.timestamp);
                    return;
                }

                // Round down to nearest timeframe interval
                const intervalStart = Math.floor(date.getTime() / 1000 / timeframeSeconds) * timeframeSeconds;
                const key = intervalStart.toString();

                if (!candleMap.has(key)) {
                    candleMap.set(key, {
                        timestamp: new Date(intervalStart * 1000).toLocaleString(),
                        open: candle.open,
                        high: candle.high,
                        low: candle.low,
                        close: candle.close,
                        bars: [candle.bar],
                        pnlSum: Number.isFinite(candle.pnl) ? candle.pnl : 0,
                        pnlCount: Number.isFinite(candle.pnl) ? 1 : 0,
                        candleTypes: [deriveCandleType(candle)]
                    });
                } else {
                    const agg = candleMap.get(key);
                    agg.high = Math.max(agg.high, candle.high);
                    agg.low = Math.min(agg.low, candle.low);
                    agg.close = candle.close; // Last close in period
                    agg.bars.push(candle.bar);
                    if (Number.isFinite(candle.pnl)) {
                        agg.pnlSum += candle.pnl;
                        agg.pnlCount += 1;
                    }
                    agg.candleTypes.push(deriveCandleType(candle));
                }
            });

            // Convert map to array and assign bar numbers
            let barNum = 0;
            const sortedKeys = Array.from(candleMap.keys()).sort((a, b) => parseInt(a) - parseInt(b));
            sortedKeys.forEach(key => {
                const agg = candleMap.get(key);
                // Calculate aggregated PNL and determine dominant candle type
                const hasPnl = (agg.pnlCount || 0) > 0;
                const aggPnl = hasPnl ? agg.pnlSum : (agg.close - agg.open);
                const typeCount = agg.candleTypes.reduce((count, type) => {
                    count[type] = (count[type] || 0) + 1;
                    return count;
                }, {});
                const dominantType = Object.keys(typeCount).reduce((a, b) => typeCount[a] > typeCount[b] ? a : b) || '';
                
                const fallbackType = deriveCandleType({ open: agg.open, close: agg.close });
                candles.push({
                    bar: barNum++,
                    timestamp: agg.timestamp,
                    open: agg.open,
                    high: agg.high,
                    low: agg.low,
                    close: agg.close,
                    pnl: aggPnl,
                    candleType: dominantType || fallbackType,
                    originalBars: agg.bars,
                    originalPnlSum: hasPnl ? agg.pnlSum : null
                });
            });

            // Map entries and exits to aggregated bars
            entries = rawEntries.map(entry => {
                const aggregatedCandle = candles.find(c => c.originalBars.includes(entry.bar));
                return aggregatedCandle ? { ...entry, bar: aggregatedCandle.bar } : null;
            }).filter(e => e !== null);

            exits = rawExits.map(exit => {
                const aggregatedCandle = candles.find(c => c.originalBars.includes(exit.bar));
                return aggregatedCandle ? { ...exit, bar: aggregatedCandle.bar } : null;
            }).filter(e => e !== null);
        }
        function generateRealTrends() {
            // Real trend analysis based on market data
            trends = [];

            const timeframeSeconds = parseInt(document.getElementById('timeframe')?.value) || 1;
            const minBarsForTrend =
                timeframeSeconds >= 1800 ? 3 :
                timeframeSeconds >= 900 ? 3 :
                timeframeSeconds >= 600 ? 3 :
                timeframeSeconds >= 300 ? 4 :
                timeframeSeconds >= 180 ? 6 :
                timeframeSeconds >= 120 ? 8 :
                timeframeSeconds >= 60 ? 10 :
                timeframeSeconds >= 30 ? 8 :
                20;

            if (candles.length < minBarsForTrend) return; // Not enough data at this timeframe
            
            const lookbackPeriod = Math.min(5, Math.max(2, Math.floor(minBarsForTrend / 2)));
            const baseMinTrendLength = Math.max(1, Math.floor(lookbackPeriod / 2));
            const minTrendLength = Number.isFinite(minTrendBarsSetting)
                ? Math.max(1, minTrendBarsSetting)
                : baseMinTrendLength;  // Slightly shorter runs to avoid missed moves
            
            let currentTrend = null;
            let trendStartIdx = lookbackPeriod;
            
            for (let i = lookbackPeriod; i < candles.length; i++) {
                const trendDirection = analyzeTrendDirection(i, lookbackPeriod);
                
                // If trend changes or we're starting
                if (currentTrend === null || currentTrend !== trendDirection) {
                    // Save previous trend if it was long enough
                    if (currentTrend !== null && (i - trendStartIdx) >= minTrendLength) {
                        trends.push({
                            type: currentTrend,
                            startBar: candles[trendStartIdx].bar,
                            endBar: candles[i - 1].bar,
                            startIdx: trendStartIdx,
                            endIdx: i - 1,
                            strength: calculateTrendStrength(trendStartIdx, i - 1)
                        });
                    }
                    
                    // Start new trend
                    currentTrend = trendDirection;
                    trendStartIdx = i;
                }
            }
            
            // Add final trend
            if (currentTrend !== null && (candles.length - trendStartIdx) >= minTrendLength) {
                trends.push({
                    type: currentTrend,
                    startBar: candles[trendStartIdx].bar,
                    endBar: candles[candles.length - 1].bar,
                    startIdx: trendStartIdx,
                    endIdx: candles.length - 1,
                    strength: calculateTrendStrength(trendStartIdx, candles.length - 1)
                });
            }
            
            console.log(`Generated ${trends.length} real trends based on market analysis:`, trends);
        }

        function sendOverlayTrendIfChanged(reason = 'overlay') {
            if (!autoSendTrends) return;
            if (!trends || trends.length === 0) return;

            const lastTrend = trends[trends.length - 1];
            const dirRaw = String(lastTrend.type || '').toUpperCase();
            const direction = dirRaw.includes('LONG') ? 'UP'
                              : dirRaw.includes('SHORT') ? 'DOWN'
                              : 'FLAT';

            // Only fire when direction flips or a new trend starts; ignore end-bar growth
            if (direction === lastOverlayDirection && lastTrend.startIdx === lastOverlayStartIdx) {
                return;
            }

            const midIdx = Math.floor((lastTrend.startIdx + lastTrend.endIdx) / 2);
            const candle = candles[midIdx] || candles[candles.length - 1];

            // Use underlying raw bars when aggregated to keep barIndex aligned with live feed
            let barIndexForCmd = candle?.bar ?? midIdx;
            if (candle?.originalBars && Array.isArray(candle.originalBars) && candle.originalBars.length > 0) {
                barIndexForCmd = Math.max(...candle.originalBars);
            }

            const payload = {
                direction,
                source: 'candles-overlay',
                barIndex: barIndexForCmd,
                price: candle?.close,
                strength: lastTrend.strength ?? 0,
                note: `overlay start:${lastTrend.startIdx} end:${lastTrend.endIdx} (${reason})`
            };

            if (logTrendFlips) {
                const flipEntry = {
                    reason,
                    direction,
                    startIdx: lastTrend.startIdx,
                    endIdx: lastTrend.endIdx,
                    barIndex: barIndexForCmd,
                    strength: lastTrend.strength ?? 0,
                    timestamp: candle?.timestamp
                };
                console.log('Trend flip', flipEntry);
                appendFlipLog(flipEntry);
            }

            lastOverlayDirection = direction;
            lastOverlayStartIdx = lastTrend.startIdx;
            sendTrendPayload(payload, reason);
        }

        // Trend Analysis Functions
        function computeVolatilityStats(startIdx, endIdx) {
            const closes = [];
            let trSum = 0;
            let count = 0;

            for (let i = startIdx; i <= endIdx; i++) {
                const candle = candles[i];
                const prevClose = candles[i - 1]?.close ?? candle.close;
                const trueRange = Math.max(
                    candle.high - candle.low,
                    Math.abs(candle.high - prevClose),
                    Math.abs(candle.low - prevClose)
                );

                trSum += trueRange;
                closes.push(candle.close);
                count++;
            }

            const mean = closes.reduce((sum, v) => sum + v, 0) / Math.max(closes.length, 1);
            const variance = closes.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / Math.max(closes.length, 1);
            const stdDev = Math.sqrt(variance);

            return {
                atr: count > 0 ? trSum / count : 0,
                stdDev,
                refPrice: closes[closes.length - 1] || 1
            };
        }

        function analyzeTrendDirection(currentIndex, lookback) {
            if (currentIndex < lookback) return 'FLAT';
            
            const startIdx = currentIndex - lookback;
            const endIdx = currentIndex;
            const timeframeSeconds = parseInt(document.getElementById('timeframe')?.value) || 1;
            const timeframeScale = Math.max(0.5, Math.min(2, timeframeSeconds / 60));
            
            // Calculate price momentum
            const startPrice = (candles[startIdx].high + candles[startIdx].low + candles[startIdx].close) / 3;
            const endPrice = (candles[endIdx].high + candles[endIdx].low + candles[endIdx].close) / 3;
            const priceChangePct = (endPrice - startPrice) / startPrice;

            // Calculate moving average slope
            const prices = candles.slice(startIdx, endIdx + 1).map(c => c.close);
            const slope = calculateLinearRegression(prices).slope;

            // Volatility-aware thresholds to stay active but not hyper-sensitive
            const { atr, stdDev, refPrice } = computeVolatilityStats(startIdx, endIdx);
            const safeRef = Math.max(refPrice, 0.0001);
            const atrPct = atr / safeRef;
            const stdPct = stdDev / safeRef;

            const basePriceThreshold = 0.00005 * timeframeScale;
            const baseSlopeThreshold = 0.0001 * timeframeScale;

            const priceChangeThreshold = Math.max(basePriceThreshold, atrPct * 0.45 + stdPct * 0.25);
            const slopePct = slope / safeRef;
            const slopeThreshold = Math.max(baseSlopeThreshold, (atrPct + stdPct) * 0.2);
            
            if (priceChangePct > priceChangeThreshold && slopePct > slopeThreshold) {
                return 'LONG';
            } else if (priceChangePct < -priceChangeThreshold && slopePct < -slopeThreshold) {
                return 'SHORT';
            }

            // Fallback: if both change and slope lean the same way, still emit a direction
            const directionalHint = basePriceThreshold * 0.5;
            if (priceChangePct > directionalHint && slopePct > 0) return 'LONG';
            if (priceChangePct < -directionalHint && slopePct < 0) return 'SHORT';

            return 'FLAT';
        }

        function appendFlipLog(entry) {
            flipLogEntries.unshift(entry);
            if (flipLogEntries.length > 50) {
                flipLogEntries = flipLogEntries.slice(0, 50);
            }
            renderFlipLog();
        }

        function renderFlipLog() {
            const listEl = document.getElementById('flipLogList');
            if (!listEl) return;
            if (flipLogEntries.length === 0) {
                listEl.textContent = 'No flips yet';
                return;
            }
            const rows = flipLogEntries.map(e => {
                const ts = e.timestamp ? new Date(e.timestamp).toLocaleTimeString() : '-';
                const strength = Number.isFinite(e.strength) ? e.strength.toFixed(2) : '';
                return `${ts}  ${e.direction}  bar:${e.barIndex}  s:${e.startIdx}->${e.endIdx}  str:${strength}  (${e.reason})`;
            });
            listEl.innerHTML = rows.join('<br>');
        }

        function updateFlipLogStatus() {
            const statusEl = document.getElementById('flipLogStatus');
            if (!statusEl) return;
            statusEl.textContent = logTrendFlips ? 'logging on' : 'logging off';
            statusEl.style.color = logTrendFlips ? '#10b981' : '#6b7280';
        }
        
        function calculateLinearRegression(values) {
            const n = values.length;
            const x = Array.from({length: n}, (_, i) => i);
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        function calculateTrendStrength(startIdx, endIdx) {
            const length = endIdx - startIdx + 1;
            const priceStart = candles[startIdx].close;
            const priceEnd = candles[endIdx].close;
            const priceChange = Math.abs(priceEnd - priceStart) / priceStart;
            
            // Strength based on price change magnitude and trend length
            return Math.min(priceChange * 100 + length / 10, 10);
        }        function calculateEMA(prices, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            // Start with SMA for first value
            let sum = 0;
            for (let i = 0; i < period && i < prices.length; i++) {
                sum += prices[i];
                ema.push(i < period - 1 ? null : sum / period);
            }
            
            // Calculate EMA for rest
            for (let i = period; i < prices.length; i++) {
                const prevEMA = ema[i - 1] || ema.find(v => v !== null);
                ema.push((prices[i] - prevEMA) * multiplier + prevEMA);
            }
            
            return ema;
        }

        function updateStats() {
            document.getElementById('stats').style.display = 'flex';
            document.getElementById('stat-bars').textContent = candles.length;
            // Use the stricter of (trend override, logged bars) so stats/PNL match the chosen minimum trend length
            const effectiveMinBars = Number.isFinite(minTrendBarsSetting) ? minTrendBarsSetting : (Number(minLoggedBarsSetting) || 2);
            const minBars = Math.max(1, effectiveMinBars);
            
            // Hide entry/exit stats since we're not using them anymore
            const entryStats = document.getElementById('stat-long');
            const shortStats = document.getElementById('stat-short');
            const exitStats = document.getElementById('stat-exits');
            if (entryStats) entryStats.parentElement.style.display = 'none';
            if (shortStats) shortStats.parentElement.style.display = 'none';
            if (exitStats) exitStats.parentElement.style.display = 'none';
            
            // Filter trends that meet the current minimum bar requirement so the threshold affects the stats and PNL
            const effectiveTrends = trends.filter(t => {
                const startIdx = t.startIdx ?? t.startIndex ?? t.index ?? 0;
                const endIdx = t.endIdx ?? t.endIndex ?? startIdx;
                return (endIdx - startIdx + 1) >= minBars;
            });

            const longTrends = effectiveTrends.filter(t => t.type === 'LONG');
            const shortTrends = effectiveTrends.filter(t => t.type === 'SHORT');
            const flatTrends = effectiveTrends.filter(t => t.type === 'FLAT');
            const neutralTrends = effectiveTrends.filter(t => t.type === 'NEUTRAL');

            const avgLongStrength = longTrends.length > 0 ? 
                (longTrends.reduce((sum, t) => sum + (t.strength || 0), 0) / longTrends.length).toFixed(1) : '0.0';
            const avgShortStrength = shortTrends.length > 0 ? 
                (shortTrends.reduce((sum, t) => sum + (t.strength || 0), 0) / shortTrends.length).toFixed(1) : '0.0';

            const setText = (id, text) => {
                const el = document.getElementById(id);
                if (el) el.textContent = text;
            };

            const setLabel = (valueId, labelText) => {
                const valueEl = document.getElementById(valueId);
                if (valueEl && valueEl.previousElementSibling) {
                    valueEl.previousElementSibling.textContent = labelText;
                }
            };

            setText('stat-long-trends', `${longTrends.length} (${avgLongStrength})`);
            setText('stat-short-trends', `${shortTrends.length} (${avgShortStrength})`);
            setText('stat-neutral-trends', `${flatTrends.length + neutralTrends.length}`);

            // Threshold-aware rollups in the formerly pattern cards
            setLabel('stat-total-patterns', `Total Trends (>= ${minBars} bars)`);
            setLabel('stat-long-patterns', `LONG (>= ${minBars} bars)`);
            setLabel('stat-short-patterns', `SHORT (>= ${minBars} bars)`);
            setLabel('stat-flat-patterns', `FLAT (>= ${minBars} bars)`);

            setText('stat-total-patterns', `${effectiveTrends.length}`);
            setText('stat-long-patterns', `${longTrends.length}`);
            setText('stat-short-patterns', `${shortTrends.length}`);
            setText('stat-flat-patterns', `${flatTrends.length + neutralTrends.length}`);

            // Aggregate total PNL across effective trends
            const totalPnl = effectiveTrends.reduce((sum, t) => {
                const sIdx = t.startIdx ?? t.startIndex ?? t.index ?? 0;
                const eIdx = t.endIdx ?? t.endIndex ?? sIdx;
                const startPrice = candles[sIdx]?.close;
                const endPrice = candles[eIdx]?.close;
                if (!Number.isFinite(startPrice) || !Number.isFinite(endPrice)) return sum;
                const dir = String(t.type || '').toUpperCase();
                const sign = dir.includes('LONG') ? 1 : dir.includes('SHORT') ? -1 : 0;
                if (sign === 0) return sum;
                return sum + (endPrice - startPrice) * sign;
            }, 0);
            const pnlLabel = totalPnl >= 0 ? `+${totalPnl.toFixed(2)}` : totalPnl.toFixed(2);
            setText('stat-total-pnl', pnlLabel);

            if (candles.length > 0) {
                const allPrices = candles.flatMap(c => [c.high, c.low]);
                const min = Math.min(...allPrices);
                const max = Math.max(...allPrices);
                document.getElementById('stat-range').textContent = `${min.toFixed(2)} - ${max.toFixed(2)}`;
            }
        }

        // =============================================
        // PATTERN ANALYSIS FUNCTIONS
        // =============================================

        function getPatternDirection(patternType) {
            // Bullish patterns suggest LONG positions
            const bullishPatterns = ['BULLISH_ENGULFING', 'HAMMER', 'DOJI_DRAGONFLY', 
                                   'THREE_WHITE_SOLDIERS', 'GOLDEN_CROSS', 'UPTREND', 
                                   'BULLISH_MOMENTUM_DIVERGENCE', 'VOLUME_BREAKOUT_UP'];
            
            // Bearish patterns suggest SHORT positions
            const bearishPatterns = ['BEARISH_ENGULFING', 'SHOOTING_STAR', 'DOJI_GRAVESTONE',
                                   'THREE_BLACK_CROWS', 'DEATH_CROSS', 'DOWNTREND',
                                   'BEARISH_MOMENTUM_DIVERGENCE', 'VOLUME_BREAKOUT_DOWN'];
            
            // Neutral patterns suggest FLAT (no position)
            const neutralPatterns = ['DOJI', 'VOLUME_SPIKE', 'SUPPORT', 'RESISTANCE', 'SIDEWAYS'];
            
            if (bullishPatterns.includes(patternType)) return 'LONG';
            if (bearishPatterns.includes(patternType)) return 'SHORT';
            return 'FLAT';
        }

        function runPatternAnalysis() {
            if (!candles || candles.length === 0) {
                alert('Please load candle data first');
                return;
            }

            console.log('üîç Starting pattern analysis...');
            detectedPatterns = [];
            trendLines = [];
            candidateTrends = [];
            supportResistanceLevels = [];
            patternDirections = { LONG: 0, SHORT: 0, FLAT: 0 };

            // Run enabled analyses
            if (document.getElementById('enableTrendDetection')?.checked) {
                try {
                    analyzeTrends();
                } catch (error) {
                    console.error('Error in trend analysis:', error);
                }
            }

            if (document.getElementById('enableCandidateTrends')?.checked) {
                try {
                    analyzeCandidateTrends();
                    sendLatestTrendIfAuto();
                } catch (error) {
                    console.error('Error in candidate trend analysis:', error);
                }
            }
            
            if (document.getElementById('enableSupportResistance')?.checked) {
                try {
                    analyzeSupportResistance();
                } catch (error) {
                    console.error('Error in support/resistance analysis:', error);
                }
            }
            
            if (document.getElementById('enableBreakouts')?.checked) {
                try {
                    analyzeBreakouts();
                } catch (error) {
                    console.error('Error in breakout detection:', error);
                }
            }
            
            if (document.getElementById('enableEngulfing').checked) {
                detectEngulfingPatterns();
            }
            
            if (document.getElementById('enableDoji').checked) {
                detectDojiPatterns();
            }
            
            if (document.getElementById('enableHammer').checked) {
                detectHammerPatterns();
            }
            
            if (document.getElementById('enableThreeSoldiers').checked) {
                detectThreeSoldiersPatterns();
            }
            
            if (document.getElementById('enableVolumeSpikes').checked) {
                analyzeVolumeSpikes();
            }
            
            if (document.getElementById('enableMomentumDivergence').checked) {
                analyzeMomentumDivergence();
            }
            
            if (document.getElementById('enableMovingAverages').checked) {
                analyzeMovingAverages();
            }

            patternOverlaysEnabled = true;
            updatePatternStats();
            drawChart(); // Redraw with patterns
            console.log(`‚úÖ Analysis complete: ${detectedPatterns.length} patterns detected`);
        }

        function clearPatternOverlays() {
            detectedPatterns = [];
            trendLines = [];
            candidateTrends = [];
            supportResistanceLevels = [];
            patternOverlaysEnabled = false;
            updatePatternStats();
            drawChart(); // Redraw without patterns
        }

        function updatePatternStats() {
            const stats = document.getElementById('patternStats');
            const patternCounts = {};
            detectedPatterns.forEach(p => {
                patternCounts[p.type] = (patternCounts[p.type] || 0) + 1;
            });

            const parts = [];
            if (Object.keys(patternCounts).length > 0) {
                const summaryText = Object.entries(patternCounts)
                    .map(([type, count]) => `${type}: ${count}`)
                    .join(' | ');
                parts.push(`Detected: ${summaryText}`);
            }

            if (candidateTrends.length > 0) {
                parts.push(`Candidate trends: ${candidateTrends.length}`);
            }

            if (parts.length === 0) {
                stats.textContent = 'No patterns detected';
            } else {
                stats.textContent = parts.join(' | ');
            }
        }
            // Debug helper to surface all annotations that touch a bar index
            function getBarDiagnostics(barIndex) {
                if (!candles || barIndex < 0 || barIndex >= candles.length) {
                    console.warn(`Bar ${barIndex} is out of range`);
                    return null;
                }

                const match = (entry) => {
                    const start = entry.startIndex ?? entry.barIndex ?? entry.index;
                    const end = entry.endIndex ?? entry.barIndex ?? entry.index;
                    return start !== undefined && end !== undefined && start <= barIndex && barIndex <= end;
                };

                const candle = candles[barIndex];
                return {
                    barIndex,
                    timestamp: candle.timestamp,
                    candle,
                    patterns: detectedPatterns.filter(match),
                    candidateTrends: candidateTrends.filter(match),
                    trends: trends.filter(match),
                    supportResistance: supportResistanceLevels.filter(match)
                };
            }

            // Expose a quick console helper: window.debugBar(42)
            window.debugBar = (barIndex) => {
                const info = getBarDiagnostics(barIndex);
                if (!info) return null;
                console.log('Bar diagnostics', info);
                return info;
            };

            // Collect a window (barIndex +/- span) for sharing or clipboard
            function getBarWindowContext(barIndex, span = 2) {
                if (!candles || barIndex < 0 || barIndex >= candles.length) return null;
                const start = Math.max(0, barIndex - span);
                const end = Math.min(candles.length - 1, barIndex + span);

                const inWindow = (idx) => idx >= start && idx <= end;
                const windowCandles = candles.slice(start, end + 1);

                const windowPatterns = detectedPatterns.filter(p => inWindow(p.barIndex ?? p.index ?? p.startIndex ?? -1));
                const windowCandidateTrends = candidateTrends.filter(t => {
                    const s = t.startIdx ?? t.startIndex ?? t.barIndex ?? t.index ?? -1;
                    const e = t.endIdx ?? t.endIndex ?? t.barIndex ?? t.index ?? s;
                    return e >= start && s <= end;
                });
                const windowTrends = trends.filter(t => {
                    const sIdx = candles.findIndex(c => c.bar === t.startBar);
                    const eIdx = candles.findIndex(c => c.bar === t.endBar);
                    if (sIdx === -1 || eIdx === -1) return false;
                    return eIdx >= start && sIdx <= end;
                });
                const windowSR = supportResistanceLevels.filter(() => true); // keep all; levels are global

                return {
                    barIndex,
                    range: { start, end },
                    candles: windowCandles,
                    patterns: windowPatterns,
                    candidateTrends: windowCandidateTrends,
                    trends: windowTrends,
                    supportResistance: windowSR
                };
            }

            // Console helper: copy a bar window to clipboard (plain text) and log it
            window.copyBarContext = (barIndex, span = 2) => {
                const ctxPayload = getBarWindowContext(barIndex, span);
                if (!ctxPayload) return null;

                const lines = [];
                lines.push(`Bar ${ctxPayload.barIndex} (range ${ctxPayload.range.start}-${ctxPayload.range.end})`);
                ctxPayload.candles.forEach((c, idx) => {
                    const label = ctxPayload.range.start + idx === ctxPayload.barIndex ? '>' : ' ';
                    lines.push(`${label} ${ctxPayload.range.start + idx} ${c.timestamp} O:${c.open} H:${c.high} L:${c.low} C:${c.close}`);
                });
                if (ctxPayload.patterns.length) {
                    lines.push('Patterns: ' + ctxPayload.patterns.map(p => `${p.type} ${(p.confidence||0)*100|0}%@${p.barIndex}`).join(', '));
                }
                if (ctxPayload.trends.length) {
                    lines.push('Trends: ' + ctxPayload.trends.map(t => `${t.type} ${t.startBar}-${t.endBar}`).join(', '));
                }
                if (ctxPayload.candidateTrends.length) {
                    lines.push('CandidateTrends: ' + ctxPayload.candidateTrends.map(t => `${t.direction||t.type||'?'}`).join(', '));
                }
                const text = lines.join('\n');

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(() => {
                        console.log(`Copied bar ${barIndex} context to clipboard`);
                    }).catch(() => {
                        console.warn('Clipboard copy failed; context logged instead');
                    });
                }
                console.log('Bar window context', ctxPayload);
                return ctxPayload;
            };

        // =============================================
        // TREND ANALYSIS
        // =============================================

        function analyzeTrends() {
            if (!candles || candles.length < 30) {
                console.log('Not enough candle data for trend analysis');
                return;
            }
            const lookback = 20;
            for (let i = lookback; i < candles.length - 5; i++) {
                const segment = candles.slice(i - lookback, i + 5);
                
                // Detect uptrends (higher lows and higher highs)
                if (detectHigherLowsAndHighs(segment)) {
                    trendLines.push({
                        type: 'UPTREND',
                        startIdx: i - lookback,
                        endIdx: i + 5,
                        strength: calculateDirectionalTrendStrength(segment, 'up')
                    });
                }
                
                // Detect downtrends (lower highs and lower lows)
                if (detectLowerHighsAndLows(segment)) {
                    trendLines.push({
                        type: 'DOWNTREND',
                        startIdx: i - lookback,
                        endIdx: i + 5,
                        strength: calculateDirectionalTrendStrength(segment, 'down')
                    });
                }
            }
        }

        function detectHigherLowsAndHighs(segment) {
            if (!segment || !Array.isArray(segment) || segment.length < 4) {
                return false;
            }
            const highs = segment.map(c => c.high);
            const lows = segment.map(c => c.low);
            const midPoint = Math.floor(segment.length / 2);
            
            const firstHalfHighs = highs.slice(0, midPoint);
            const secondHalfHighs = highs.slice(midPoint);
            const firstHalfLows = lows.slice(0, midPoint);
            const secondHalfLows = lows.slice(midPoint);
            
            const avgFirstHigh = firstHalfHighs.reduce((a, b) => a + b, 0) / firstHalfHighs.length;
            const avgSecondHigh = secondHalfHighs.reduce((a, b) => a + b, 0) / secondHalfHighs.length;
            const avgFirstLow = firstHalfLows.reduce((a, b) => a + b, 0) / firstHalfLows.length;
            const avgSecondLow = secondHalfLows.reduce((a, b) => a + b, 0) / secondHalfLows.length;
            
            return avgSecondHigh > avgFirstHigh && avgSecondLow > avgFirstLow;
        }

        function detectLowerHighsAndLows(segment) {
            if (!segment || !Array.isArray(segment) || segment.length < 4) {
                return false;
            }
            const highs = segment.map(c => c.high);
            const lows = segment.map(c => c.low);
            const midPoint = Math.floor(segment.length / 2);
            
            const firstHalfHighs = highs.slice(0, midPoint);
            const secondHalfHighs = highs.slice(midPoint);
            const firstHalfLows = lows.slice(0, midPoint);
            const secondHalfLows = lows.slice(midPoint);
            
            const avgFirstHigh = firstHalfHighs.reduce((a, b) => a + b, 0) / firstHalfHighs.length;
            const avgSecondHigh = secondHalfHighs.reduce((a, b) => a + b, 0) / secondHalfHighs.length;
            const avgFirstLow = firstHalfLows.reduce((a, b) => a + b, 0) / firstHalfLows.length;
            const avgSecondLow = secondHalfLows.reduce((a, b) => a + b, 0) / secondHalfLows.length;
            
            return avgSecondHigh < avgFirstHigh && avgSecondLow < avgFirstLow;
        }

        function calculateDirectionalTrendStrength(segment, direction) {
            if (!segment || !Array.isArray(segment) || segment.length < 2) {
                return 0;
            }
            const prices = segment.map(c => c.close);
            let strength = 0;
            
            for (let i = 1; i < prices.length; i++) {
                if (direction === 'up' && prices[i] > prices[i-1]) strength++;
                if (direction === 'down' && prices[i] < prices[i-1]) strength++;
            }
            
            return strength / (prices.length - 1);
        }

        // Lightweight slope-based candidate trends for missed moves
        function analyzeCandidateTrends() {
            if (!candles || candles.length < 15) return;

            const minRun = 2;
            const minChange = 0.0005; // 0.05% move for sensitivity
            const minSlopePerBar = 0.00001;

            let i = 0;
            while (i + minRun <= candles.length) {
                const baseSegment = candles.slice(i, i + minRun);
                const baseCloses = baseSegment.map(c => c.close);
                const baseReg = calculateLinearRegression(baseCloses);
                const baseDir = baseReg.slope > 0 ? 'UP' : baseReg.slope < 0 ? 'DOWN' : null;
                const baseChange = (baseCloses[baseCloses.length - 1] - baseCloses[0]) / baseCloses[0];
                const slopePerBar = Math.abs(baseReg.slope) / baseCloses[0];

                if (!baseDir || Math.abs(baseChange) < minChange || slopePerBar < minSlopePerBar) {
                    i++;
                    continue;
                }

                let end = i + minRun;
                while (end < candles.length) {
                    const extended = candles.slice(i, end + 1);
                    const extendedCloses = extended.map(c => c.close);
                    const { slope: extSlope } = calculateLinearRegression(extendedCloses);
                    const extDir = extSlope > 0 ? 'UP' : extSlope < 0 ? 'DOWN' : null;
                    const extChange = (extendedCloses[extendedCloses.length - 1] - extendedCloses[0]) / extendedCloses[0];
                    const extSlopePerBar = Math.abs(extSlope) / extendedCloses[0];

                    if (extDir !== baseDir || Math.abs(extChange) < minChange || extSlopePerBar < minSlopePerBar * 0.5) {
                        break;
                    }
                    end++;
                }

                const finalSegment = candles.slice(i, end);
                const finalCloses = finalSegment.map(c => c.close);
                const { slope: finalSlope } = calculateLinearRegression(finalCloses);
                const finalChange = (finalCloses[finalCloses.length - 1] - finalCloses[0]) / finalCloses[0];

                candidateTrends.push({
                    direction: baseDir,
                    startIdx: i,
                    endIdx: end - 1,
                    change: finalChange,
                    slopePerBar: Math.abs(finalSlope) / finalCloses[0]
                });

                i = end;
            }

            // If nothing found, retry once with ultra-lenient thresholds
            if (candidateTrends.length === 0) {
                const fallbackMinChange = 0.0001;
                const fallbackMinSlopePerBar = 0.0;
                let j = 0;
                while (j + minRun <= candles.length) {
                    const seg = candles.slice(j, j + minRun);
                    const closes = seg.map(c => c.close);
                    const reg = calculateLinearRegression(closes);
                    const dir = reg.slope > 0 ? 'UP' : reg.slope < 0 ? 'DOWN' : null;
                    const chg = (closes[closes.length - 1] - closes[0]) / closes[0];
                    const slopePB = Math.abs(reg.slope) / closes[0];

                    if (!dir || Math.abs(chg) < fallbackMinChange || slopePB < fallbackMinSlopePerBar) {
                        j++;
                        continue;
                    }

                    let k = j + minRun;
                    while (k < candles.length) {
                        const ext = candles.slice(j, k + 1);
                        const extCloses = ext.map(c => c.close);
                        const { slope: extSlope } = calculateLinearRegression(extCloses);
                        const extDir = extSlope > 0 ? 'UP' : extSlope < 0 ? 'DOWN' : null;
                        const extChange = (extCloses[extCloses.length - 1] - extCloses[0]) / extCloses[0];
                        const extSlopePB = Math.abs(extSlope) / extCloses[0];
                        if (extDir !== dir || Math.abs(extChange) < fallbackMinChange || extSlopePB < fallbackMinSlopePerBar) {
                            break;
                        }
                        k++;
                    }

                    candidateTrends.push({
                        direction: dir,
                        startIdx: j,
                        endIdx: k - 1,
                        change: (candles[k - 1].close - candles[j].close) / candles[j].close,
                        slopePerBar: Math.abs(reg.slope) / closes[0]
                    });

                    j = k;
                }
            }
        }

        // =============================================
        // SUPPORT/RESISTANCE ANALYSIS
        // =============================================

        function analyzeSupportResistance() {
            const allPrices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceStep = (maxPrice - minPrice) / 50; // 50 levels

            for (let level = minPrice; level <= maxPrice; level += priceStep) {
                const touches = countPriceTouches(level, priceStep / 2);
                
                if (touches >= 3) { // Minimum 3 touches for valid level
                    const isSupport = isLevelSupport(level);
                    supportResistanceLevels.push({
                        price: level,
                        type: isSupport ? 'SUPPORT' : 'RESISTANCE',
                        strength: touches,
                        tested: touches
                    });
                }
            }
        }

        function countPriceTouches(level, tolerance) {
            let touches = 0;
            candles.forEach(candle => {
                if (Math.abs(candle.low - level) <= tolerance || 
                    Math.abs(candle.high - level) <= tolerance) {
                    touches++;
                }
            });
            return touches;
        }

        function isLevelSupport(level) {
            let bounces = 0;
            let breaks = 0;
            
            candles.forEach((candle, i) => {
                if (i === 0) return;
                
                const prevCandle = candles[i-1];
                if (candle.low <= level && candle.close > level && prevCandle.close > level) {
                    bounces++;
                }
                if (candle.close < level && prevCandle.close >= level) {
                    breaks++;
                }
            });
            
            return bounces > breaks;
        }

        // =============================================
        // CANDLESTICK PATTERN DETECTION
        // =============================================

        function detectEngulfingPatterns() {
            for (let i = 1; i < candles.length; i++) {
                const current = candles[i];
                const previous = candles[i-1];
                
                // Bullish Engulfing
                if (isBearish(previous) && isBullish(current) &&
                    current.open < previous.close && current.close > previous.open) {
                    const pattern = {
                        type: 'BULLISH_ENGULFING',
                        barIndex: i,
                        confidence: calculateEngulfingConfidence(current, previous),
                        candle: current,
                        direction: 'LONG'
                    };
                    detectedPatterns.push(pattern);
                    patternDirections.LONG++;
                }
                
                // Bearish Engulfing
                if (isBullish(previous) && isBearish(current) &&
                    current.open > previous.close && current.close < previous.open) {
                    const pattern = {
                        type: 'BEARISH_ENGULFING',
                        barIndex: i,
                        confidence: calculateEngulfingConfidence(current, previous),
                        candle: current,
                        direction: 'SHORT'
                    };
                    detectedPatterns.push(pattern);
                    patternDirections.SHORT++;
                }
            }
        }

        function detectDojiPatterns() {
            candles.forEach((candle, i) => {
                if (isDoji(candle)) {
                    const context = getMarketContext(i);
                    const patternType = 'DOJI';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: calculateDojiConfidence(candle, context),
                        context: context,
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
            });
        }

        function detectHammerPatterns() {
            candles.forEach((candle, i) => {
                const bodySize = Math.abs(candle.close - candle.open);
                const totalRange = candle.high - candle.low;
                const upperShadow = candle.high - Math.max(candle.open, candle.close);
                const lowerShadow = Math.min(candle.open, candle.close) - candle.low;
                
                // Hammer: small body, long lower shadow, short upper shadow
                if (bodySize < totalRange * 0.3 && lowerShadow > bodySize * 2 && upperShadow < bodySize * 0.5) {
                    const patternType = 'HAMMER';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: calculateHammerConfidence(candle),
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
                
                // Shooting Star: small body, long upper shadow, short lower shadow
                if (bodySize < totalRange * 0.3 && upperShadow > bodySize * 2 && lowerShadow < bodySize * 0.5) {
                    const patternType = 'SHOOTING_STAR';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: calculateHammerConfidence(candle),
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
            });
        }

        function detectThreeSoldiersPatterns() {
            for (let i = 2; i < candles.length; i++) {
                const c1 = candles[i-2];
                const c2 = candles[i-1];
                const c3 = candles[i];
                
                // Three White Soldiers
                if (isBullish(c1) && isBullish(c2) && isBullish(c3) &&
                    c2.close > c1.close && c3.close > c2.close &&
                    c2.open > c1.open && c2.open < c1.close &&
                    c3.open > c2.open && c3.open < c2.close) {
                    const patternType = 'THREE_WHITE_SOLDIERS';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: 0.8,
                        candle: c3,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
                
                // Three Black Crows
                if (isBearish(c1) && isBearish(c2) && isBearish(c3) &&
                    c2.close < c1.close && c3.close < c2.close &&
                    c2.open < c1.open && c2.open > c1.close &&
                    c3.open < c2.open && c3.open > c2.close) {
                    const patternType = 'THREE_BLACK_CROWS';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: 0.8,
                        candle: c3,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
            }
        }

        // =============================================
        // VOLUME & MOMENTUM ANALYSIS
        // =============================================

        function analyzeVolumeSpikes() {
            // Check if any candles have volume data
            const hasVolumeData = candles.some(c => c.volume && c.volume > 0);
            if (!hasVolumeData) {
                console.log('No volume data found in candles');
                return;
            }
            
            const volumes = candles.map(c => c.volume || 0);
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            console.log(`Volume analysis: avg=${avgVolume.toFixed(0)}, threshold=${(avgVolume * 2).toFixed(0)}`);
            
            let spikesFound = 0;
            candles.forEach((candle, i) => {
                if (candle.volume && candle.volume > avgVolume * 1.5) { // Lower threshold for more sensitivity
                    const patternType = 'VOLUME_SPIKE';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: Math.min(candle.volume / avgVolume / 3, 1.0),
                        volumeRatio: candle.volume / avgVolume,
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                    spikesFound++;
                }
            });
            console.log(`Volume spikes found: ${spikesFound}`);
        }

        function analyzeMomentumDivergence() {
            // Price vs momentum divergence detection
            const lookback = 14;
            for (let i = lookback; i < candles.length - lookback; i++) {
                const priceChange = candles[i].close - candles[i - lookback].close;
                const futureChange = candles[i + lookback].close - candles[i].close;
                
                // Bullish divergence: price making lower lows but momentum improving
                if (priceChange < 0 && futureChange > Math.abs(priceChange) * 0.5) {
                    detectedPatterns.push({
                        type: 'BULLISH_DIVERGENCE',
                        barIndex: i,
                        confidence: Math.min(Math.abs(futureChange / priceChange), 1.0),
                        candle: candles[i]
                    });
                }
            }
        }

        function analyzeMovingAverages() {
            const shortMA = calculateSMA(9);
            const longMA = calculateSMA(21);
            
            for (let i = 21; i < candles.length; i++) {
                const shortCurrent = shortMA[i];
                const shortPrevious = shortMA[i-1];
                const longCurrent = longMA[i];
                const longPrevious = longMA[i-1];
                
                // Golden Cross (bullish)
                if (shortPrevious <= longPrevious && shortCurrent > longCurrent) {
                    detectedPatterns.push({
                        type: 'GOLDEN_CROSS',
                        barIndex: i,
                        confidence: 0.7,
                        candle: candles[i]
                    });
                }
                
                // Death Cross (bearish)
                if (shortPrevious >= longPrevious && shortCurrent < longCurrent) {
                    detectedPatterns.push({
                        type: 'DEATH_CROSS',
                        barIndex: i,
                        confidence: 0.7,
                        candle: candles[i]
                    });
                }
            }
        }

        // =============================================
        // BREAKOUT ANALYSIS
        // =============================================

        function analyzeBreakouts() {
            supportResistanceLevels.forEach(level => {
                candles.forEach((candle, i) => {
                    if (level.type === 'RESISTANCE' && candle.close > level.price && candles[i-1]?.close <= level.price) {
                        detectedPatterns.push({
                            type: 'RESISTANCE_BREAKOUT',
                            barIndex: i,
                            confidence: Math.min(level.strength / 10, 1.0),
                            level: level.price,
                            candle: candle
                        });
                    }
                    
                    if (level.type === 'SUPPORT' && candle.close < level.price && candles[i-1]?.close >= level.price) {
                        detectedPatterns.push({
                            type: 'SUPPORT_BREAKDOWN',
                            barIndex: i,
                            confidence: Math.min(level.strength / 10, 1.0),
                            level: level.price,
                            candle: candle
                        });
                    }
                });
            });
        }

        // =============================================
        // UTILITY FUNCTIONS
        // =============================================

        function isBullish(candle) { return candle.close > candle.open; }
        function isBearish(candle) { return candle.close < candle.open; }
        function isDoji(candle) {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalRange = candle.high - candle.low;
            return bodySize < totalRange * 0.1;
        }

        function calculateSMA(period) {
            const sma = [];
            for (let i = 0; i < candles.length; i++) {
                if (i < period - 1) {
                    sma.push(null);
                } else {
                    let sum = 0;
                    for (let j = i - period + 1; j <= i; j++) {
                        sum += candles[j].close;
                    }
                    sma.push(sum / period);
                }
            }
            return sma;
        }

        function calculateEngulfingConfidence(current, previous) {
            const currentBody = Math.abs(current.close - current.open);
            const previousBody = Math.abs(previous.close - previous.open);
            return Math.min(currentBody / previousBody / 2, 1.0);
        }

        function calculateDojiConfidence(candle, context) {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalRange = candle.high - candle.low;
            return 1 - (bodySize / totalRange);
        }

        function calculateHammerConfidence(candle) {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalRange = candle.high - candle.low;
            return 1 - (bodySize / totalRange);
        }

        function getMarketContext(index) {
            if (index < 5) return 'INSUFFICIENT_DATA';
            const recent = candles.slice(index - 5, index);
            const avgClose = recent.reduce((sum, c) => sum + c.close, 0) / recent.length;
            return candles[index].close > avgClose ? 'UPTREND_CONTEXT' : 'DOWNTREND_CONTEXT';
        }

        function drawChart() {
            try {
                canvas = document.getElementById('chartCanvas');
                
                if (!candles || candles.length === 0) {
                    console.error('No candles to draw');
                    return;
                }

                // Set canvas size FIRST to reset any error state
                const container = canvas.parentElement;
                const idealWidth = Math.max(container.clientWidth - 40, candles.length * 12);
                const maxCanvasWidth = 32000; // Browser limit is typically 32767
                const newWidth = Math.min(idealWidth, maxCanvasWidth);
                const newHeight = 600;
                
                console.log(`Canvas sizing: candles=${candles.length}, idealWidth=${idealWidth}, newWidth=${newWidth}`);
                
                // Validate dimensions before applying
                if (!isFinite(newWidth) || !isFinite(newHeight) || newWidth <= 0 || newHeight <= 0) {
                    console.error('Invalid canvas dimensions:', newWidth, newHeight);
                    return;
                }
                
                // Setting dimensions clears canvas and resets context
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // Get fresh context after resizing
                ctx = canvas.getContext('2d');
                tooltip = document.getElementById('tooltip');
                
                if (!ctx) {
                    console.error('Failed to get canvas context');
                    return;
                }

            // Calculate price range with zoom
            const allPrices = candles.flatMap(c => [c.high, c.low]).filter(p => isFinite(p));
            if (allPrices.length === 0) {
                console.error('No valid prices found');
                return;
            }
            
            const minPriceRaw = Math.min(...allPrices);
            const maxPriceRaw = Math.max(...allPrices);
            const priceCenter = (minPriceRaw + maxPriceRaw) / 2;
            const priceRangeRaw = maxPriceRaw - minPriceRaw;
            
            // Apply zoom by scaling around the center
            const zoomedRange = priceRangeRaw / priceZoom;
            let minPrice = priceCenter - zoomedRange / 2 + priceOffset;
            let maxPrice = priceCenter + zoomedRange / 2 + priceOffset;
            const pricePadding = zoomedRange * 0.1;

            if (!isFinite(minPrice) || !isFinite(maxPrice) || zoomedRange <= 0) {
                console.error('Invalid price range:', minPrice, maxPrice, zoomedRange);
                return;
            }

            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const baseSpacing = chartWidth / candles.length;
            const candleSpacing = baseSpacing * timeZoom;
            const candleWidth = Math.max(2, Math.min(20, candleSpacing * 0.7));

            // Validate critical dimensions
            if (!isFinite(candleSpacing) || candleSpacing <= 0) {
                console.error('Invalid candleSpacing:', candleSpacing, 'chartWidth:', chartWidth, 'candles.length:', candles.length);
                throw new Error('Invalid chart dimensions');
            }
            if (!isFinite(chartHeight) || chartHeight <= 0) {
                console.error('Invalid chartHeight:', chartHeight);
                throw new Error('Invalid chart height');
            }

            // Clear canvas
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply horizontal pan offset by translating canvas
            const panPixels = candleOffset * candleSpacing;
            ctx.save();
            ctx.translate(-panPixels, 0);

            // Draw trend background zones FIRST (behind everything)
            console.log('About to draw', trends.length, 'trend backgrounds');
            console.log('candleSpacing:', candleSpacing, 'chartHeight:', chartHeight, 'chartPadding:', chartPadding);
            trends.forEach((trend, trendIdx) => {
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                const endIdx = candles.findIndex(c => c.bar === trend.endBar);
                if (startIdx === -1 || endIdx === -1) {
                    console.warn(`Trend ${trendIdx}: bars not found`, trend);
                    return;
                }

                const startX = chartPadding.left + startIdx * candleSpacing;
                const endX = chartPadding.left + (endIdx + 1) * candleSpacing;
                const width = endX - startX;

                console.log(`Trend ${trendIdx}: startX=${startX}, endX=${endX}, width=${width}`);

                // Validate coordinates before drawing
                if (!isFinite(startX) || !isFinite(endX) || !isFinite(width) || 
                    !isFinite(chartPadding.top) || !isFinite(chartHeight) ||
                    width <= 0 || chartHeight <= 0) {
                    console.warn('Skipping trend with invalid coordinates:', trend, {startX, endX, width, chartHeight});
                    return;
                }

                // Color based on trend type with consistent opacity (no strength variation)
                const baseOpacity = 0.3; // Fixed opacity for consistent colors
                
                if (trend.type === 'LONG') {
                    ctx.fillStyle = `rgba(16, 185, 129, ${baseOpacity})`;
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                } else if (trend.type === 'SHORT') {
                    ctx.fillStyle = `rgba(239, 68, 68, ${baseOpacity})`;
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                } else if (trend.type === 'NEUTRAL') {
                    ctx.fillStyle = `rgba(75, 85, 99, ${baseOpacity * 0.6})`; // Darker gray for no-data zones
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                } else {
                    // FLAT trends - light gray
                    ctx.fillStyle = `rgba(156, 163, 175, ${baseOpacity * 0.8})`;
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                }
                
                // Add trend label with strength
                if (width > 60) { // Only show label if trend is wide enough
                    ctx.fillStyle = trend.type === 'LONG' ? '#10b981' : 
                                   trend.type === 'SHORT' ? '#ef4444' : 
                                   trend.type === 'NEUTRAL' ? '#4b5563' : '#9ca3af';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    const labelX = startX + width / 2;
                    const labelY = chartPadding.top + 15;
                    ctx.fillText(`${trend.type}`, labelX, labelY);
                    
                    // Show strength if significant
                    if (trend.strength && trend.strength > 1) {
                        ctx.font = '8px monospace';
                        ctx.fillText(`(${trend.strength.toFixed(1)})`, labelX, labelY + 12);
                    }
                }
                
                console.log(`Trend ${trendIdx}: drew successfully`);
            });

            // Draw grid
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines (price levels)
            const numPriceLines = 8;
            console.log('Drawing', numPriceLines, 'horizontal grid lines');
            for (let i = 0; i <= numPriceLines; i++) {
                const y = chartPadding.top + (chartHeight / numPriceLines) * i;
                
                // Validate grid line coordinates
                if (!isFinite(y) || !isFinite(chartPadding.left) || !isFinite(canvas.width) || !isFinite(chartPadding.right)) {
                    console.warn(`Skipping grid line ${i} with invalid coordinates: y=${y}, left=${chartPadding.left}, width=${canvas.width}, right=${chartPadding.right}`);
                    continue;
                }
                
                const x1 = chartPadding.left;
                const x2 = canvas.width - chartPadding.right;
                console.log(`Grid line ${i}: y=${y}, x1=${x1}, x2=${x2}`);
                
                if (!isFinite(x1) || !isFinite(x2)) {
                    console.warn(`Grid line ${i} has invalid x coordinates: x1=${x1}, x2=${x2}`);
                    continue;
                }
                
                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();
            }

            // Draw candles
            candles.forEach((candle, index) => {
                // Validate candle data
                if (!candle || !isFinite(candle.open) || !isFinite(candle.high) || 
                    !isFinite(candle.low) || !isFinite(candle.close)) {
                    console.warn(`Skipping invalid candle at index ${index}:`, candle);
                    return;
                }
                
                const x = chartPadding.left + index * candleSpacing + candleSpacing / 2;
                
                const openY = chartPadding.top + ((maxPrice + pricePadding - candle.open) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const closeY = chartPadding.top + ((maxPrice + pricePadding - candle.close) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const highY = chartPadding.top + ((maxPrice + pricePadding - candle.high) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const lowY = chartPadding.top + ((maxPrice + pricePadding - candle.low) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                // Validate all calculated coordinates
                if (!isFinite(x) || !isFinite(openY) || !isFinite(closeY) || 
                    !isFinite(highY) || !isFinite(lowY)) {
                    console.warn(`Skipping candle with invalid coordinates at index ${index}`);
                    return;
                }

                const isBullish = candle.close > candle.open;
                ctx.fillStyle = isBullish ? '#10b981' : '#ef4444';
                ctx.strokeStyle = isBullish ? '#10b981' : '#ef4444';

                // Draw wick (high-low line)
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body (open-close rectangle)
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(2, Math.abs(closeY - openY));
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
            });

            // Draw entry markers
            entries.forEach(entry => {
                const candleIndex = candles.findIndex(c => c.bar === entry.bar);
                if (candleIndex === -1) return;

                const x = chartPadding.left + candleIndex * candleSpacing + candleSpacing / 2;
                const candle = candles[candleIndex];
                const price = entry.price || candle.close;
                
                if (!isFinite(price)) return;
                
                const priceY = chartPadding.top + ((maxPrice + pricePadding - price) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                if (!isFinite(x) || !isFinite(priceY)) return;

                ctx.fillStyle = entry.direction === 'LONG' ? '#10b981' : '#ef4444';
                ctx.beginPath();
                if (entry.direction === 'LONG') {
                    // Upward triangle for LONG
                    ctx.moveTo(x, priceY - 10);
                    ctx.lineTo(x - 6, priceY);
                    ctx.lineTo(x + 6, priceY);
                } else {
                    // Downward triangle for SHORT
                    ctx.moveTo(x, priceY + 10);
                    ctx.lineTo(x - 6, priceY);
                    ctx.lineTo(x + 6, priceY);
                }
                ctx.closePath();
                ctx.fill();
            });

            // Draw exit markers
            exits.forEach(exit => {
                const candleIndex = candles.findIndex(c => c.bar === exit.bar);
                if (candleIndex === -1) return;

                const x = chartPadding.left + candleIndex * candleSpacing + candleSpacing / 2;
                const candle = candles[candleIndex];
                const price = exit.price || candle.close;
                
                if (!isFinite(price)) return;
                
                const priceY = chartPadding.top + ((maxPrice + pricePadding - price) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                if (!isFinite(x) || !isFinite(priceY)) return;

                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(x, priceY, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#0f1419';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw trend boundary lines
            trends.forEach(trend => {
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                const endIdx = candles.findIndex(c => c.bar === trend.endBar);
                if (startIdx === -1 || endIdx === -1) return;

                // Skip drawing lines for FLAT trends
                if (trend.type === 'FLAT') return;

                const color = trend.type === 'LONG' ? '#10b981' : '#ef4444';
                
                // Start line
                const startX = chartPadding.left + startIdx * candleSpacing;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(startX, chartPadding.top);
                ctx.lineTo(startX, canvas.height - chartPadding.bottom);
                ctx.stroke();

                // End line
                const endX = chartPadding.left + (endIdx + 1) * candleSpacing;
                ctx.beginPath();
                ctx.moveTo(endX, chartPadding.top);
                ctx.lineTo(endX, canvas.height - chartPadding.bottom);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label at top
                if (isFinite(startX) && isFinite(chartPadding.top)) {
                    ctx.fillStyle = color;
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    const label = trend.type === 'LONG' ? '‚ñ≤ LONG' : '‚ñº SHORT';
                    ctx.fillText(label, startX + 5, chartPadding.top - 10);
                    
                    // Trend duration
                    const duration = trend.endBar - trend.startBar + 1;
                    ctx.font = '9px monospace';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText(`${duration} bars`, startX + 5, chartPadding.top - 22);
                }
            });

            // Draw FLAT trend labels (no lines, just labels)
            trends.forEach(trend => {
                if (trend.type !== 'FLAT') return;
                
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                if (startIdx === -1) return;

                const startX = chartPadding.left + startIdx * candleSpacing;
                
                // Label at top
                if (isFinite(startX) && isFinite(chartPadding.top)) {
                    ctx.fillStyle = '#9ca3af'; // Gray color for FLAT
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('‚Äî FLAT', startX + 5, chartPadding.top - 10);
                    
                    // Trend duration
                    const duration = trend.endBar - trend.startBar + 1;
                    ctx.font = '9px monospace';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText(`${duration} bars`, startX + 5, chartPadding.top - 22);
                }
            });

            // Draw timestamps on x-axis
            ctx.fillStyle = '#9ca3af';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const labelEvery = Math.max(1, Math.floor(candles.length / 20));
            candles.forEach((candle, index) => {
                if (index % labelEvery === 0 || index === candles.length - 1) {
                    const x = chartPadding.left + index * candleSpacing + candleSpacing / 2;
                    if (isFinite(x) && candle.timestamp) {
                        // Parse timestamp and format as local time
                        try {
                            const date = new Date(candle.timestamp);
                            const timeString = date.toLocaleTimeString('en-US', { 
                                hour12: false, 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            });
                            ctx.fillText(timeString, x, canvas.height - chartPadding.bottom + 20);
                        } catch (e) {
                            // Fallback to bar number if timestamp parsing fails
                            ctx.fillText(candle.bar || index, x, canvas.height - chartPadding.bottom + 20);
                        }
                    }
                }
            });



            canvas.onmouseleave = function() {
                tooltip.classList.remove('show');
                lastHoverIndex = null;
                isDragging = false;
            };
            
            // Restore before drawing fixed axes so they don't pan
            ctx.restore();

            // =============================================
            // DRAW PRICE AXIS (uses current zoom/pan price range)
            // =============================================
            
            // Use the already calculated maxPrice, minPrice, pricePadding from chart
            const numPriceLinesAxis = 8;
            
            // Draw price labels on left side
            for (let i = 0; i <= numPriceLinesAxis; i++) {
                const y = chartPadding.top + (chartHeight / numPriceLinesAxis) * i;
                const price = maxPrice + pricePadding - ((maxPrice - minPrice + 2 * pricePadding) / numPriceLinesAxis) * i;
                
                if (isFinite(price) && isFinite(y)) {
                    const labelText = price.toFixed(2);
                    
                    // Draw price label on left side
                    ctx.font = '12px monospace';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'left';
                    ctx.fillText(labelText, 10, y + 4);
                    
                    // Also draw horizontal grid lines
                    ctx.strokeStyle = '#374151';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(chartPadding.left, y);
                    ctx.lineTo(canvas.width - chartPadding.right, y);
                    ctx.stroke();
                }
            }

            // =============================================
            // DRAW PATTERN OVERLAYS
            // =============================================
            if (patternOverlaysEnabled) {
                // Save context for overlay drawing
                ctx.save();
                ctx.translate(-panPixels, 0);

                // Draw trend lines
                drawTrendLines(candleSpacing, chartHeight, chartPadding, canvas, ctx, maxPrice, minPrice);

                // Draw lightweight candidate trend overlays
                drawCandidateTrends(candleSpacing, chartHeight, chartPadding, canvas, ctx, maxPrice, minPrice);

                // Draw support/resistance levels
                drawSupportResistanceLevels(candleSpacing, chartHeight, chartPadding, canvas, ctx);

                // Draw pattern markers
                drawPatternMarkers(candleSpacing, chartHeight, chartPadding, canvas, ctx, maxPrice, minPrice, pricePadding);

                // Restore context
                ctx.restore();
            }

            // Mouse wheel zoom (vertical)
            canvas.onwheel = function(e) {
                e.preventDefault();
                const zoomSpeed = 0.1;
                if (e.deltaY < 0) {
                    priceZoom *= (1 + zoomSpeed); // Zoom in (stretch)
                } else {
                    priceZoom *= (1 - zoomSpeed); // Zoom out (compress)
                }
                priceZoom = Math.max(0.1, Math.min(10, priceZoom)); // Limit zoom range
                drawChart();
            };

            // Right-click drag: horizontal zoom; left-click drag: pan/vertical pan
            canvas.oncontextmenu = function(e) { e.preventDefault(); };

            canvas.onmousedown = function(e) {
                if (e.button === 2) {
                    isTimeZoomDrag = true;
                    dragStartX = e.clientX;
                    canvas.style.cursor = 'ew-resize';
                    return;
                }
                // If user is holding a modifier, treat as click-only (no pan)
                if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                    return;
                }
                isDragging = true;
                dragStartY = e.clientY;
                dragStartX = e.clientX;
            };

            canvas.onmouseup = function() {
                isDragging = false;
                isTimeZoomDrag = false;
                canvas.style.cursor = 'default';
            };

            canvas.onmousemove = function(e) {
                if (isTimeZoomDrag) {
                    const deltaX = e.clientX - dragStartX;
                    const factor = Math.exp(deltaX * 0.002);
                    timeZoom = Math.min(5, Math.max(0.2, timeZoom * factor));
                    dragStartX = e.clientX;
                    drawChart();
                    return;
                }

                if (isDragging) {
                    const deltaY = e.clientY - dragStartY;
                    const deltaX = e.clientX - dragStartX;
                    
                    // Only apply vertical pan if significant vertical movement
                    if (Math.abs(deltaY) > Math.abs(deltaX)) {
                        // Vertical panning (up/down) - EXTREMELY LESS sensitive and INVERTED
                        const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
                        const zoomedRange = (maxPriceRaw / priceZoom);
                        const priceShift = (deltaY / chartHeight) * zoomedRange * 0.005; // Much less sensitive (reduced from 0.02 to 0.005)
                        priceOffset += priceShift;
                        dragStartY = e.clientY;
                    } else {
                        // Horizontal panning (left/right) - MORE sensitive
                        const panSpeed = 0.1; // Increased from 0.02
                        const candlesToMove = -deltaX * panSpeed;
                        candleOffset += candlesToMove;
                        candleOffset = Math.max(0, Math.min(candles.length - 1, candleOffset));
                        dragStartX = e.clientX;
                    }
                    
                    drawChart();
                } else {
                    // Show tooltip only when not dragging
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Check if mouse is within chart area
                    if (mouseX >= chartPadding.left && mouseX <= canvas.width - chartPadding.right) {
                        const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
                        const candleSpacing = (chartWidth / candles.length) * timeZoom;
                        
                        // Account for panning offset when calculating candle index
                        const panPixels = candleOffset * candleSpacing;
                        const adjustedMouseX = mouseX + panPixels;
                        const candleIndex = Math.floor((adjustedMouseX - chartPadding.left) / candleSpacing);
                        
                        if (candleIndex >= 0 && candleIndex < candles.length) {
                            const candle = candles[candleIndex];
                            lastHoverIndex = candleIndex;
                            showTooltip(candle, candleIndex, e.clientX, e.clientY);
                        } else {
                            lastHoverIndex = null;
                            tooltip.classList.remove('show');
                        }
                    } else {
                        lastHoverIndex = null;
                        tooltip.classList.remove('show');
                    }
                }
            };

            // Click: capture bar context (¬±2 bars) and log/copy for chat
            canvas.onclick = function(e) {
                if (isDragging || isTimeZoomDrag) return;

                // Require a modifier to avoid interfering with normal pan/zoom
                if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey)) return;

                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                if (mouseX < chartPadding.left || mouseX > canvas.width - chartPadding.right) return;

                const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
                const candleSpacingLocal = (chartWidth / candles.length) * timeZoom;
                const panPixelsLocal = candleOffset * candleSpacingLocal;
                const adjustedMouseX = mouseX + panPixelsLocal;
                const candleIndex = Math.floor((adjustedMouseX - chartPadding.left) / candleSpacingLocal);

                if (candleIndex >= 0 && candleIndex < candles.length) {
                    copyBarContext(candleIndex, 2);
                }
            };
            } catch (error) {
                console.error('Error drawing chart:', error);
                // Display error message on canvas
                if (ctx) {
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '14px monospace';
                    ctx.fillText('Error drawing chart. Check console for details.', 20, 50);
                }
            }
        }

        // =============================================
        // PATTERN OVERLAY DRAWING FUNCTIONS
        // =============================================

        function drawTrendLines(candleSpacing, chartHeight, chartPadding, canvas, ctx, maxPrice, minPrice) {
            if (!document.getElementById('enableTrendDetection').checked) return;

            trendLines.forEach(trend => {
                if (trend.startIdx < 0 || trend.endIdx >= candles.length) return;

                // Use consistent spacing calculation that matches main chart
                const startX = chartPadding.left + trend.startIdx * candleSpacing + candleSpacing / 2;
                const endX = chartPadding.left + trend.endIdx * candleSpacing + candleSpacing / 2;
                
                const startCandle = candles[trend.startIdx];
                const endCandle = candles[trend.endIdx];
                        const priceRange = maxPrice - minPrice;
                        if (!isFinite(priceRange) || priceRange <= 0) return;

                let startY, endY;
                if (trend.type === 'UPTREND') {
                    startY = chartPadding.top + ((maxPrice - startCandle.low) / priceRange) * chartHeight;
                    endY = chartPadding.top + ((maxPrice - endCandle.high) / priceRange) * chartHeight;
                    ctx.strokeStyle = '#10b981';
                } else {
                    startY = chartPadding.top + ((maxPrice - startCandle.high) / priceRange) * chartHeight;
                    endY = chartPadding.top + ((maxPrice - endCandle.low) / priceRange) * chartHeight;
                    ctx.strokeStyle = '#ef4444';
                }

                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.globalAlpha = 0.7;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = 'bold 10px monospace';
                ctx.fillText(trend.type, (startX + endX) / 2, (startY + endY) / 2 - 10);
                
                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;
            });
        }

        function drawCandidateTrends(candleSpacing, chartHeight, chartPadding, canvas, ctx, maxPrice, minPrice) {
            if (!document.getElementById('enableCandidateTrends').checked) return;

            const priceRange = maxPrice - minPrice;
            if (!isFinite(priceRange) || priceRange <= 0) return;

            candidateTrends.forEach(trend => {
                if (trend.startIdx < 0 || trend.endIdx >= candles.length) return;

                const startX = chartPadding.left + trend.startIdx * candleSpacing + candleSpacing / 2;
                const endX = chartPadding.left + trend.endIdx * candleSpacing + candleSpacing / 2;

                const startPrice = candles[trend.startIdx].close;
                const endPrice = candles[trend.endIdx].close;
                const startY = chartPadding.top + ((maxPrice - startPrice) / priceRange) * chartHeight;
                const endY = chartPadding.top + ((maxPrice - endPrice) / priceRange) * chartHeight;

                ctx.strokeStyle = trend.direction === 'UP' ? '#22d3ee' : '#f472b6';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([2, 4]);
                ctx.globalAlpha = 0.9;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;

                const label = `${trend.direction === 'UP' ? '‚ñ≤' : '‚ñº'} ${(trend.change * 100).toFixed(1)}%`;
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = 'bold 10px monospace';
                ctx.fillText(label, (startX + endX) / 2, (startY + endY) / 2 - 8);
            });
        }

        function drawSupportResistanceLevels(candleSpacing, chartHeight, chartPadding, canvas, ctx) {
            if (!document.getElementById('enableSupportResistance').checked) return;

            const allPrices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice;

            supportResistanceLevels.forEach(level => {
                const y = chartPadding.top + ((maxPrice - level.price) / priceRange) * chartHeight;
                
                if (level.type === 'SUPPORT') {
                    ctx.strokeStyle = '#10b981';
                } else {
                    ctx.strokeStyle = '#ef4444';
                }
                
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                ctx.setLineDash([3, 3]);
                
                ctx.beginPath();
                ctx.moveTo(chartPadding.left, y);
                ctx.lineTo(canvas.width - chartPadding.right, y);
                ctx.stroke();
                
                // Label with strength
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = '10px monospace';
                ctx.fillText(`${level.type} ${level.price.toFixed(2)} (${level.strength}x)`, 
                           chartPadding.left + 5, y - 5);
                
                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;
            });
        }

        function drawPatternMarkers(candleSpacing, chartHeight, chartPadding, canvas, ctx, maxPrice, minPrice, pricePadding) {
            const priceRange = (maxPrice - minPrice) + 2 * pricePadding;

            detectedPatterns.forEach(pattern => {
                if (pattern.barIndex < 0 || pattern.barIndex >= candles.length) return;

                // Use consistent spacing calculation that matches main chart
                const x = chartPadding.left + pattern.barIndex * candleSpacing + candleSpacing / 2;
                const candle = pattern.candle || candles[pattern.barIndex];
                let y = chartPadding.top + ((maxPrice + pricePadding - candle.high) / priceRange) * chartHeight - 20;

                // Choose marker style and color based on pattern type
                let color = '#60a5fa';
                let symbol = '‚óè';
                let size = 8;

                if (pattern.type.includes('BULLISH') || pattern.type.includes('GOLDEN') || pattern.type.includes('WHITE')) {
                    color = '#10b981';
                    symbol = '‚ñ≤';
                } else if (pattern.type.includes('BEARISH') || pattern.type.includes('DEATH') || pattern.type.includes('BLACK')) {
                    color = '#ef4444';
                    symbol = '‚ñº';
                } else if (pattern.type.includes('DOJI')) {
                    color = '#f59e0b';
                    symbol = '‚óÜ';
                } else if (pattern.type.includes('HAMMER')) {
                    color = '#8b5cf6';
                    symbol = 'üî®';
                    size = 12;
                } else if (pattern.type.includes('VOLUME')) {
                    color = '#06b6d4';
                    symbol = 'üìä';
                    size = 14; // Make volume spikes more prominent
                }

                // Draw marker background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, size + 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw marker
                ctx.fillStyle = color;
                ctx.font = `${size}px monospace`;
                ctx.textAlign = 'center';
                ctx.fillText(symbol, x, y + size/3);

                // Draw pattern label
                ctx.fillStyle = color;
                ctx.font = 'bold 9px monospace';
                ctx.textAlign = 'center';
                const label = pattern.type.replace(/_/g, ' ');
                ctx.fillText(label, x, y - size - 5);

                // Draw confidence indicator
                if (pattern.confidence) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '8px monospace';
                    ctx.fillText(`${(pattern.confidence * 100).toFixed(0)}%`, x, y + size + 12);
                }
            });
        }

        function showTooltip(candle, index, clientX, clientY) {
            const entryAtBar = entries.find(e => e.bar === candle.bar);
            const exitAtBar = exits.find(e => e.bar === candle.bar);
            const patternsAtBar = detectedPatterns.filter(p => p.barIndex === index);

            // Prefer summed PNL when available, otherwise fall back to candle PNL or close-open
            const pnlValue = Number.isFinite(candle.originalPnlSum)
                ? candle.originalPnlSum
                : Number.isFinite(candle.pnl)
                    ? candle.pnl
                    : (Number.isFinite(candle.close) && Number.isFinite(candle.open)
                        ? candle.close - candle.open
                        : 0);
            const pnlColor = pnlValue >= 0 ? '#10b981' : '#ef4444';

            const candleType = deriveCandleType(candle);
            const candleTypeLower = typeof candleType === 'string' ? candleType.toLowerCase() : '';
            const candleTypeColor = candleTypeLower === 'good' ? '#10b981' : candleTypeLower === 'bad' ? '#ef4444' : '#9ca3af';

            let html = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Bar:</span>
                    <span class="tooltip-value">${candle.bar}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Time:</span>
                    <span class="tooltip-value">${candle.timestamp || 'N/A'}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Open:</span>
                    <span class="tooltip-value">${candle.open.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">High:</span>
                    <span class="tooltip-value">${candle.high.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Low:</span>
                    <span class="tooltip-value">${candle.low.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Close:</span>
                    <span class="tooltip-value">${candle.close.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">PNL:</span>
                    <span class="tooltip-value" style="color: ${pnlColor};">${pnlValue.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Candle:</span>
                    <span class="tooltip-value" style="color: ${candleTypeColor};">${candleType || 'N/A'}</span>
                </div>
            `;

            if (entryAtBar) {
                html += `
                    <div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #374151; padding-top: 6px;">
                        <span class="tooltip-label">Entry:</span>
                        <span class="tooltip-value" style="color: ${entryAtBar.direction === 'LONG' ? '#10b981' : '#ef4444'};">${entryAtBar.direction}</span>
                    </div>
                `;
            }

            if (exitAtBar) {
                html += `
                    <div class="tooltip-row" style="margin-top: 4px;">
                        <span class="tooltip-label">Exit:</span>
                        <span class="tooltip-value" style="color: #f59e0b;">Yes</span>
                    </div>
                `;
            }

            // Add pattern information
            if (patternsAtBar.length > 0) {
                html += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #374151; padding-top: 6px;">`;
                html += `<span class="tooltip-label">Patterns:</span>`;
                html += `</div>`;
                
                patternsAtBar.forEach(pattern => {
                    const confidence = pattern.confidence ? ` (${(pattern.confidence * 100).toFixed(0)}%)` : '';
                    let patternColor = '#60a5fa';
                    
                    if (pattern.type.includes('BULLISH') || pattern.type.includes('GOLDEN') || pattern.type.includes('WHITE')) {
                        patternColor = '#10b981';
                    } else if (pattern.type.includes('BEARISH') || pattern.type.includes('DEATH') || pattern.type.includes('BLACK')) {
                        patternColor = '#ef4444';
                    } else if (pattern.type.includes('DOJI')) {
                        patternColor = '#f59e0b';
                    }
                    
                    html += `
                        <div class="tooltip-row" style="margin-left: 12px;">
                            <span class="tooltip-value" style="color: ${patternColor};">‚Ä¢ ${pattern.type.replace(/_/g, ' ')}${confidence}</span>
                        </div>
                    `;
                });
            }

            tooltip.innerHTML = html;
            tooltip.classList.add('show');
            tooltip.style.visibility = 'hidden';

            // Measure and position within the chart container using relative coords
            const container = tooltip.parentElement;
            const containerRect = container.getBoundingClientRect();
            const rect = tooltip.getBoundingClientRect();

            // Start near the cursor relative to container
            let left = (clientX - containerRect.left) + 15;
            let top = (clientY - containerRect.top) - rect.height - 10; // prefer above

            // If above goes off container, place below cursor
            if (top < 8) {
                top = (clientY - containerRect.top) + 15;
            }

            // Clamp within container bounds with small padding
            left = Math.min(containerRect.width - rect.width - 8, Math.max(8, left));
            top = Math.min(containerRect.height - rect.height - 8, Math.max(8, top));

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
            tooltip.style.visibility = 'visible';
        }

        // Export current analysis state as JSON for sharing/debugging
        async function downloadAnalysis() {
            if (!candles || candles.length === 0) {
                alert('Load data and run Analyze first');
                return;
            }

            const payload = {
                generatedAt: new Date().toISOString(),
                stats: {
                    candles: candles.length,
                    patterns: detectedPatterns.length,
                    candidateTrends: candidateTrends.length,
                    trends: trends.length
                },
                candles,
                detectedPatterns,
                candidateTrends,
                trends,
                entries,
                exits,
                viewState: {
                    priceZoom,
                    timeZoom,
                    candleOffset,
                    priceOffset
                }
            };

            // Save server-side into strategy_logs
            try {
                const res = await fetch('/logs/save-analysis', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const json = await res.json();
                if (!res.ok) {
                    console.warn('Server save failed:', json);
                } else {
                    console.log('Analysis saved to server:', json);
                }
            } catch (err) {
                console.warn('Server save failed:', err);
            }

            // Client-side download
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'analysis.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Send the most recent candidate trend to the strategy via the server command bridge
        async function sendLatestTrendToStrategy() {
            if (!candidateTrends || candidateTrends.length === 0) {
                alert('No candidate trends to send');
                return;
            }
            const trend = candidateTrends[candidateTrends.length - 1];
            await sendTrendPayload(trend, 'manual');
        }

        // Manual test buttons
        async function sendManualTrend(direction) {
            if (!candles || candles.length === 0) {
                alert('No candles loaded');
                return;
            }
            const last = candles[candles.length - 1];
            const trend = {
                direction: direction,
                startIdx: last.bar ?? candles.length - 1,
                endIdx: last.bar ?? candles.length - 1,
                change: 0,
                strength: 0,
                note: 'manual-button'
            };
            await sendTrendPayload(trend, `manual-${direction.toLowerCase()}`);
        }

        function toggleAutoSendTrends() {
            autoSendTrends = !autoSendTrends;
            const btn = document.getElementById('autoSendToggle');
            if (btn) {
                btn.textContent = `Auto Send Trends: ${autoSendTrends ? 'On' : 'Off'}`;
                btn.style.background = autoSendTrends ? '#10b981' : '#f97316';
            }
            updateLiveStatus(autoSendTrends ? 'auto-send ON' : 'auto-send OFF');
        }

        let enableCommandSend = false; // toggle to true if you want to actually POST commands

        async function sendTrendPayload(trend, reason = 'auto') {
            if (!trend) return;
            const dirRaw = String(trend.direction || trend.type || '').toUpperCase();
            const direction = dirRaw.includes('FLAT') || dirRaw.includes('NEUTRAL') ? 'FLAT'
                              : (dirRaw.includes('UP') || dirRaw.includes('LONG')) ? 'UP'
                              : (dirRaw.includes('DOWN') || dirRaw.includes('SHORT')) ? 'DOWN'
                              : 'FLAT';


            const startIdx = trend.startIdx ?? trend.startIndex ?? trend.index ?? 0;
            const endIdx = trend.endIdx ?? trend.endIndex ?? startIdx;
            const midIdx = Math.floor((startIdx + endIdx) / 2);
            const candle = candles[midIdx] || candles[candles.length - 1];

            // Use the latest underlying raw bar index when aggregated timeframe is active
            let barIndexForCmd = candle?.bar ?? midIdx;
            if (candle?.originalBars && Array.isArray(candle.originalBars) && candle.originalBars.length > 0) {
                barIndexForCmd = Math.max(...candle.originalBars);
            }

            const payload = {
                direction,
                source: 'candles.html',
                barIndex: barIndexForCmd,
                price: candle?.close,
                strength: trend.change ?? trend.strength,
                note: `start:${startIdx} end:${endIdx} (${reason})`
            };

            const key = `${direction}:${startIdx}-${endIdx}`;
            if (reason === 'auto' && key === lastSentTrendKey) {
                return; // avoid duplicate sends for same segment
            }

            try {
                if (enableCommandSend) {
                    const res = await fetch('/commands/trend', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const json = await res.json();
                    if (!res.ok) {
                        console.warn('Send trend failed', json);
                        updateLiveStatus('command failed', '#f97316');
                    } else {
                        lastSentTrendKey = key;
                        console.log('Trend command sent', json);
                        updateLiveStatus(`trend -> ${direction} (#${json.command?.id || ''})`, '#10b981');
                    }
                } else {
                    console.log('Trend command NOT sent (sending disabled)', payload);
                    updateLiveStatus(`send disabled -> ${direction}`, '#9ca3af');
                }
            } catch (err) {
                console.warn('Error sending trend', err);
                updateLiveStatus('command error', '#ef4444');
            }
        }

        async function sendLatestTrendIfAuto() {
            if (!autoSendTrends) return;
            if (!candidateTrends || candidateTrends.length === 0) return;
            const trend = candidateTrends[candidateTrends.length - 1];
            await sendTrendPayload(trend, 'auto');
        }

        // Add event listeners for analysis checkboxes and controls
        document.addEventListener('DOMContentLoaded', () => {
            const analysisCheckboxes = document.querySelectorAll('.analysis-controls input[type="checkbox"]');
            const flipLogCheckbox = document.getElementById('enableFlipLogging');
            
            if (flipLogCheckbox) {
                logTrendFlips = flipLogCheckbox.checked;
                flipLogCheckbox.addEventListener('change', () => {
                    logTrendFlips = flipLogCheckbox.checked;
                    updateFlipLogStatus();
                    if (!logTrendFlips && flipLogEntries.length === 0) {
                        renderFlipLog();
                    }
                    recomputeAndRedraw('flip-log-toggle');
                });
                updateFlipLogStatus();
            }

            updateTrendLogStatus();

            analysisCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    if (candles.length > 0) {
                        runPatternAnalysis();
                        drawChart();
                    }
                });
            });

            // Select All button
            document.getElementById('selectAll').addEventListener('click', () => {
                analysisCheckboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
                if (candles.length > 0) {
                    runPatternAnalysis();
                    drawChart();
                }
            });

            // Select None button
            document.getElementById('selectNone').addEventListener('click', () => {
                analysisCheckboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                if (candles.length > 0) {
                    runPatternAnalysis();
                    drawChart();
                }
            });

            // Hotkey: press 'b' while hovering the chart to copy the hovered bar window (¬±2)
            document.addEventListener('keydown', (e) => {
                if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;
                if (e.key === 'b' && lastHoverIndex !== null) {
                    copyBarContext(lastHoverIndex, 2);
                }
            });

            // Seed the chart with cached bars so a refresh keeps context before live data resumes
            preloadRecentBars();
        });

        // Auto-resize chart
        window.addEventListener('resize', () => {
            if (candles.length > 0) {
                drawChart();
            }
        });
        initMinLoggedBarsControl();
        initMinTrendBarsControl();
    </script>
</body>
</html>
