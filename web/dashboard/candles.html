<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candle Chart - Strategy Logs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #1a1f3a 0%, #2d3561 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        input[type="file"] {
            padding: 8px;
            background: #1a1f3a;
            border: 1px solid #374151;
            border-radius: 5px;
            color: #e0e0e0;
            cursor: pointer;
        }

        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: #2563eb;
        }

        .stats {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-card {
            background: #1a1f3a;
            padding: 12px 16px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            min-width: 120px;
        }

        .stat-label {
            font-size: 11px;
            color: #9ca3af;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #60a5fa;
        }

        .chart-container {
            background: #1a1f3a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            overflow-x: auto;
            position: relative;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .tooltip {
            position: absolute;
            background: rgba(26, 31, 58, 0.95);
            border: 1px solid #60a5fa;
            border-radius: 5px;
            padding: 10px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            font-size: 12px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tooltip.show {
            display: block;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-bottom: 3px;
        }

        .tooltip-label {
            color: #9ca3af;
        }

        .tooltip-value {
            color: #e0e0e0;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #9ca3af;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #fca5a5;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-size: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .long-entry { background: #10b981; }
        .short-entry { background: #ef4444; }
        .exit { background: #f59e0b; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ“Š Candle Chart from Strategy Logs</h1>
        <p>Upload a CSV file from strategy_logs to visualize price action and trades</p>
        
        <div class="controls">
            <input type="file" id="fileInput" accept=".csv" />
            <button onclick="loadFromServer()">Load Latest from Server</button>
            <span id="status" style="color: #9ca3af; font-size: 12px;"></span>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: #10b981; border: 2px solid #10b981;"></div>
                <span>Bullish Candle</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #ef4444; border: 2px solid #ef4444;"></div>
                <span>Bearish Candle</span>
            </div>
            <div class="legend-item">
                <div class="legend-box long-entry"></div>
                <span>LONG Entry</span>
            </div>
            <div class="legend-item">
                <div class="legend-box short-entry"></div>
                <span>SHORT Entry</span>
            </div>
            <div class="legend-item">
                <div class="legend-box exit"></div>
                <span>Exit</span>
            </div>
        </div>
    </div>

    <div style="margin: 20px; display: flex; align-items: center; gap: 15px;">
        <label style="color: #9ca3af; font-weight: 500;">Timeframe:</label>
        <select id="timeframe" style="background: #1f2937; color: #e5e7eb; border: 1px solid #374151; padding: 8px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
            <option value="1">Raw Data (as recorded)</option>
            <option value="30">30 seconds</option>
            <option value="60">1 minute</option>
            <option value="120">2 minutes</option>
            <option value="300">5 minutes</option>
            <option value="600">10 minutes</option>
            <option value="900">15 minutes</option>
            <option value="1800">30 minutes</option>
            <option value="3600">1 hour</option>
        </select>
    </div>

    <div class="stats" id="stats" style="display: none;">
        <div class="stat-card">
            <div class="stat-label">Total Bars</div>
            <div class="stat-value" id="stat-bars">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">LONG Entries</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">SHORT Entries</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Exits</div>
            <div class="stat-value" style="color: #f59e0b;" id="stat-exits">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Price Range</div>
            <div class="stat-value" id="stat-range">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #10b981;">
            <div class="stat-label">LONG Trends</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long-trends">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #ef4444;">
            <div class="stat-label">SHORT Trends</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short-trends">0</div>
        </div>
    </div>

    <div class="chart-container">
        <canvas id="chartCanvas"></canvas>
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        let rawCandles = []; // Original data
        let rawEntries = [];
        let rawExits = [];
        let candles = []; // Aggregated data for display
        let entries = [];
        let exits = [];
        let trends = [];
        let ctx, tooltip;
        let priceZoom = 1.0; // Vertical zoom factor for price axis
        let priceOffset = 0; // Vertical pan offset (in price units)
        let isDragging = false;
        let dragStartY = 0;
        let dragStartX = 0;
        let candleOffset = 0; // Horizontal scroll offset (in candles)
        let chartPadding = { top: 40, right: 80, bottom: 40, left: 80 };

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('timeframe').addEventListener('change', function() {
            if (rawCandles.length > 0) {
                aggregateCandles();
                detectTrends();
                updateStats();
                drawChart();
            }
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('status').textContent = 'Reading file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parseCSV(e.target.result);
                    document.getElementById('status').textContent = `Loaded: ${file.name}`;
                } catch (error) {
                    document.getElementById('status').innerHTML = `<span style="color: #ef4444;">Error: ${error.message}</span>`;
                }
            };
            reader.readAsText(file);
        }

        async function loadFromServer() {
            document.getElementById('status').textContent = 'Loading from server...';
            try {
                // Try to get latest CSV from server
                const response = await fetch('/logs/latest-csv');
                if (!response.ok) throw new Error(`Server returned ${response.status}`);
                
                const csvText = await response.text();
                const filename = response.headers.get('X-Log-Filename') || 'latest csv';
                parseCSV(csvText);
                document.getElementById('status').textContent = `Loaded from server: ${filename}`;
            } catch (error) {
                document.getElementById('status').innerHTML = `<span style="color: #ef4444;">Error: ${error.message}</span>`;
            }
        }

        function parseCSV(csvText) {
            // Reset previously loaded data so uploads don't accumulate
            rawCandles = [];
            rawEntries = [];
            rawExits = [];
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) throw new Error('CSV file is empty or invalid');

            // Parse header
            const header = lines[0].split(',').map(h => h.trim());
            const barCol = header.indexOf('Bar');
            const timestampCol = header.indexOf('Timestamp');

            // Find OHLC columns (they might have different names)
            const openCol = header.findIndex(h => h.toLowerCase().includes('open'));
            const highCol = header.findIndex(h => h.toLowerCase().includes('high'));
            const lowCol = header.findIndex(h => h.toLowerCase().includes('low'));
            const closeCol = header.findIndex(h => h.toLowerCase().includes('close'));

            candles = [];
            entries = [];
            exits = [];
            const candleByBar = new Map();

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const cols = line.split(',').map(c => c.trim());
                
                const bar = parseInt(cols[barCol]) || i;
                const timestamp = cols[timestampCol] || '';

                // Extract OHLC if available
                const open = parseFloat(cols[openCol]) || null;
                const high = parseFloat(cols[highCol]) || null;
                const low = parseFloat(cols[lowCol]) || null;
                const close = parseFloat(cols[closeCol]) || null;

                // Store candle data if we have price info
                if (open !== null && high !== null && low !== null && close !== null) {
                    candleByBar.set(bar, { bar, timestamp, open, high, low, close });
                }
            }

            rawCandles = Array.from(candleByBar.values())
                .map(c => ({ bar: c.bar, timestamp: c.timestamp, open: c.open, high: c.high, low: c.low, close: c.close }))
                .sort((a, b) => a.bar - b.bar);

            if (rawCandles.length === 0) {
                throw new Error('No valid candle data found in CSV. Make sure the file has Open, High, Low, Close columns.');
            }

            // Initial aggregation
            aggregateCandles();

            // Generate simple test trends: LONG, FLAT, SHORT every 10 bars
            generateTestTrends();

            updateStats();
            drawChart();
        }

        function aggregateCandles() {
            const timeframeSeconds = parseInt(document.getElementById('timeframe').value);
            
            if (timeframeSeconds === 1) {
                // No aggregation - use raw data
                candles = [...rawCandles].sort((a, b) => a.bar - b.bar);
                entries = [...rawEntries];
                exits = [...rawExits];
                return;
            }

            // Parse timestamps and group by timeframe
            candles = [];
            const candleMap = new Map();

            rawCandles.forEach(candle => {
                // Parse timestamp - format: MM/dd/yyyy HH:mm:ss
                const date = new Date(candle.timestamp);
                if (isNaN(date.getTime())) {
                    console.warn('Invalid timestamp:', candle.timestamp);
                    return;
                }

                // Round down to nearest timeframe interval
                const intervalStart = Math.floor(date.getTime() / 1000 / timeframeSeconds) * timeframeSeconds;
                const key = intervalStart.toString();

                if (!candleMap.has(key)) {
                    candleMap.set(key, {
                        timestamp: new Date(intervalStart * 1000).toLocaleString(),
                        open: candle.open,
                        high: candle.high,
                        low: candle.low,
                        close: candle.close,
                        bars: [candle.bar]
                    });
                } else {
                    const agg = candleMap.get(key);
                    agg.high = Math.max(agg.high, candle.high);
                    agg.low = Math.min(agg.low, candle.low);
                    agg.close = candle.close; // Last close in period
                    agg.bars.push(candle.bar);
                }
            });

            // Convert map to array and assign bar numbers
            let barNum = 0;
            const sortedKeys = Array.from(candleMap.keys()).sort((a, b) => parseInt(a) - parseInt(b));
            sortedKeys.forEach(key => {
                const agg = candleMap.get(key);
                candles.push({
                    bar: barNum++,
                    timestamp: agg.timestamp,
                    open: agg.open,
                    high: agg.high,
                    low: agg.low,
                    close: agg.close,
                    originalBars: agg.bars
                });
            });

            // Map entries and exits to aggregated bars
            entries = rawEntries.map(entry => {
                const aggregatedCandle = candles.find(c => c.originalBars.includes(entry.bar));
                return aggregatedCandle ? { ...entry, bar: aggregatedCandle.bar } : null;
            }).filter(e => e !== null);

            exits = rawExits.map(exit => {
                const aggregatedCandle = candles.find(c => c.originalBars.includes(exit.bar));
                return aggregatedCandle ? { ...exit, bar: aggregatedCandle.bar } : null;
            }).filter(e => e !== null);
        }
        function generateTestTrends() {
            // Simple test trend generation: LONG, SHORT, FLAT every 10 bars
            trends = [];
            const trendCycle = ['LONG', 'SHORT', 'FLAT'];
            let currentTrendIdx = 0;
            let trendStartIdx = 0;

            for (let i = 0; i < candles.length; i++) {
                const barsInCurrentTrend = i - trendStartIdx;
                
                if (barsInCurrentTrend >= 10) {
                    // Save current trend
                    trends.push({
                        type: trendCycle[currentTrendIdx % 3],
                        startBar: candles[trendStartIdx].bar,
                        endBar: candles[i - 1].bar,
                        startIdx: trendStartIdx,
                        endIdx: i - 1
                    });
                    
                    // Move to next trend cycle
                    currentTrendIdx++;
                    trendStartIdx = i;
                }
            }

            // Save final trend
            if (trendStartIdx < candles.length) {
                trends.push({
                    type: trendCycle[currentTrendIdx % 3],
                    startBar: candles[trendStartIdx].bar,
                    endBar: candles[candles.length - 1].bar,
                    startIdx: trendStartIdx,
                    endIdx: candles.length - 1
                });
            }

            console.log(`Generated ${trends.length} test trends:`, trends);
        }

        function calculateEMA(prices, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            // Start with SMA for first value
            let sum = 0;
            for (let i = 0; i < period && i < prices.length; i++) {
                sum += prices[i];
                ema.push(i < period - 1 ? null : sum / period);
            }
            
            // Calculate EMA for rest
            for (let i = period; i < prices.length; i++) {
                const prevEMA = ema[i - 1] || ema.find(v => v !== null);
                ema.push((prices[i] - prevEMA) * multiplier + prevEMA);
            }
            
            return ema;
        }

        function updateStats() {
            document.getElementById('stats').style.display = 'flex';
            document.getElementById('stat-bars').textContent = candles.length;
            
            // Hide entry/exit stats since we're not using them anymore
            const entryStats = document.getElementById('stat-long');
            const shortStats = document.getElementById('stat-short');
            const exitStats = document.getElementById('stat-exits');
            if (entryStats) entryStats.parentElement.style.display = 'none';
            if (shortStats) shortStats.parentElement.style.display = 'none';
            if (exitStats) exitStats.parentElement.style.display = 'none';
            
            // Show trend stats
            document.getElementById('stat-long-trends').textContent = trends.filter(t => t.type === 'LONG').length;
            document.getElementById('stat-short-trends').textContent = trends.filter(t => t.type === 'SHORT').length;

            if (candles.length > 0) {
                const allPrices = candles.flatMap(c => [c.high, c.low]);
                const min = Math.min(...allPrices);
                const max = Math.max(...allPrices);
                document.getElementById('stat-range').textContent = `${min.toFixed(2)} - ${max.toFixed(2)}`;
            }
        }

        function drawChart() {
            try {
                canvas = document.getElementById('chartCanvas');
                
                if (!candles || candles.length === 0) {
                    console.error('No candles to draw');
                    return;
                }

                // Set canvas size FIRST to reset any error state
                const container = canvas.parentElement;
                const idealWidth = Math.max(container.clientWidth - 40, candles.length * 12);
                const maxCanvasWidth = 32000; // Browser limit is typically 32767
                const newWidth = Math.min(idealWidth, maxCanvasWidth);
                const newHeight = 600;
                
                console.log(`Canvas sizing: candles=${candles.length}, idealWidth=${idealWidth}, newWidth=${newWidth}`);
                
                // Validate dimensions before applying
                if (!isFinite(newWidth) || !isFinite(newHeight) || newWidth <= 0 || newHeight <= 0) {
                    console.error('Invalid canvas dimensions:', newWidth, newHeight);
                    return;
                }
                
                // Setting dimensions clears canvas and resets context
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // Get fresh context after resizing
                ctx = canvas.getContext('2d');
                tooltip = document.getElementById('tooltip');
                
                if (!ctx) {
                    console.error('Failed to get canvas context');
                    return;
                }

            // Calculate price range with zoom
            const allPrices = candles.flatMap(c => [c.high, c.low]).filter(p => isFinite(p));
            if (allPrices.length === 0) {
                console.error('No valid prices found');
                return;
            }
            
            const minPriceRaw = Math.min(...allPrices);
            const maxPriceRaw = Math.max(...allPrices);
            const priceCenter = (minPriceRaw + maxPriceRaw) / 2;
            const priceRangeRaw = maxPriceRaw - minPriceRaw;
            
            // Apply zoom by scaling around the center
            const zoomedRange = priceRangeRaw / priceZoom;
            let minPrice = priceCenter - zoomedRange / 2 + priceOffset;
            let maxPrice = priceCenter + zoomedRange / 2 + priceOffset;
            const pricePadding = zoomedRange * 0.1;

            if (!isFinite(minPrice) || !isFinite(maxPrice) || zoomedRange <= 0) {
                console.error('Invalid price range:', minPrice, maxPrice, zoomedRange);
                return;
            }

            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const candleWidth = Math.max(6, Math.min(20, chartWidth / candles.length * 0.7));
            const candleSpacing = chartWidth / candles.length;

            // Validate critical dimensions
            if (!isFinite(candleSpacing) || candleSpacing <= 0) {
                console.error('Invalid candleSpacing:', candleSpacing, 'chartWidth:', chartWidth, 'candles.length:', candles.length);
                throw new Error('Invalid chart dimensions');
            }
            if (!isFinite(chartHeight) || chartHeight <= 0) {
                console.error('Invalid chartHeight:', chartHeight);
                throw new Error('Invalid chart height');
            }

            // Clear canvas
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply horizontal pan offset by translating canvas
            const panPixels = candleOffset * candleSpacing;
            ctx.save();
            ctx.translate(-panPixels, 0);

            // Draw trend background zones FIRST (behind everything)
            console.log('About to draw', trends.length, 'trend backgrounds');
            console.log('candleSpacing:', candleSpacing, 'chartHeight:', chartHeight, 'chartPadding:', chartPadding);
            trends.forEach((trend, trendIdx) => {
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                const endIdx = candles.findIndex(c => c.bar === trend.endBar);
                if (startIdx === -1 || endIdx === -1) {
                    console.warn(`Trend ${trendIdx}: bars not found`, trend);
                    return;
                }

                const startX = chartPadding.left + startIdx * candleSpacing;
                const endX = chartPadding.left + (endIdx + 1) * candleSpacing;
                const width = endX - startX;

                console.log(`Trend ${trendIdx}: startX=${startX}, endX=${endX}, width=${width}`);

                // Validate coordinates before drawing
                if (!isFinite(startX) || !isFinite(endX) || !isFinite(width) || 
                    !isFinite(chartPadding.top) || !isFinite(chartHeight) ||
                    width <= 0 || chartHeight <= 0) {
                    console.warn('Skipping trend with invalid coordinates:', trend, {startX, endX, width, chartHeight});
                    return;
                }

                // Semi-transparent background
                if (trend.type === 'LONG') {
                    ctx.fillStyle = 'rgba(16, 185, 129, 0.08)';
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                } else if (trend.type === 'SHORT') {
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.08)';
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                }
                // FLAT trends have no background color
                console.log(`Trend ${trendIdx}: drew successfully`);
            });

            // Draw grid
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines (price levels)
            const numPriceLines = 8;
            console.log('Drawing', numPriceLines, 'horizontal grid lines');
            for (let i = 0; i <= numPriceLines; i++) {
                const y = chartPadding.top + (chartHeight / numPriceLines) * i;
                
                // Validate grid line coordinates
                if (!isFinite(y) || !isFinite(chartPadding.left) || !isFinite(canvas.width) || !isFinite(chartPadding.right)) {
                    console.warn(`Skipping grid line ${i} with invalid coordinates: y=${y}, left=${chartPadding.left}, width=${canvas.width}, right=${chartPadding.right}`);
                    continue;
                }
                
                const x1 = chartPadding.left;
                const x2 = canvas.width - chartPadding.right;
                console.log(`Grid line ${i}: y=${y}, x1=${x1}, x2=${x2}`);
                
                if (!isFinite(x1) || !isFinite(x2)) {
                    console.warn(`Grid line ${i} has invalid x coordinates: x1=${x1}, x2=${x2}`);
                    continue;
                }
                
                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();

                // Price labels
                const price = maxPrice + pricePadding - ((maxPrice - minPrice + 2 * pricePadding) / numPriceLines) * i;
                if (isFinite(price) && isFinite(y)) {
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '11px monospace';
                    ctx.textAlign = 'right';
                    ctx.fillText(price.toFixed(2), chartPadding.left - 10, y + 4);
                }
            }

            // Draw candles
            candles.forEach((candle, index) => {
                // Validate candle data
                if (!candle || !isFinite(candle.open) || !isFinite(candle.high) || 
                    !isFinite(candle.low) || !isFinite(candle.close)) {
                    console.warn(`Skipping invalid candle at index ${index}:`, candle);
                    return;
                }
                
                const x = chartPadding.left + index * candleSpacing + candleSpacing / 2;
                
                const openY = chartPadding.top + ((maxPrice + pricePadding - candle.open) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const closeY = chartPadding.top + ((maxPrice + pricePadding - candle.close) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const highY = chartPadding.top + ((maxPrice + pricePadding - candle.high) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const lowY = chartPadding.top + ((maxPrice + pricePadding - candle.low) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                // Validate all calculated coordinates
                if (!isFinite(x) || !isFinite(openY) || !isFinite(closeY) || 
                    !isFinite(highY) || !isFinite(lowY)) {
                    console.warn(`Skipping candle with invalid coordinates at index ${index}`);
                    return;
                }

                const isBullish = candle.close > candle.open;
                ctx.fillStyle = isBullish ? '#10b981' : '#ef4444';
                ctx.strokeStyle = isBullish ? '#10b981' : '#ef4444';

                // Draw wick (high-low line)
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body (open-close rectangle)
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(2, Math.abs(closeY - openY));
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
            });

            // Draw entry markers
            entries.forEach(entry => {
                const candleIndex = candles.findIndex(c => c.bar === entry.bar);
                if (candleIndex === -1) return;

                const x = chartPadding.left + candleIndex * candleSpacing + candleSpacing / 2;
                const candle = candles[candleIndex];
                const price = entry.price || candle.close;
                
                if (!isFinite(price)) return;
                
                const priceY = chartPadding.top + ((maxPrice + pricePadding - price) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                if (!isFinite(x) || !isFinite(priceY)) return;

                ctx.fillStyle = entry.direction === 'LONG' ? '#10b981' : '#ef4444';
                ctx.beginPath();
                if (entry.direction === 'LONG') {
                    // Upward triangle for LONG
                    ctx.moveTo(x, priceY - 10);
                    ctx.lineTo(x - 6, priceY);
                    ctx.lineTo(x + 6, priceY);
                } else {
                    // Downward triangle for SHORT
                    ctx.moveTo(x, priceY + 10);
                    ctx.lineTo(x - 6, priceY);
                    ctx.lineTo(x + 6, priceY);
                }
                ctx.closePath();
                ctx.fill();
            });

            // Draw exit markers
            exits.forEach(exit => {
                const candleIndex = candles.findIndex(c => c.bar === exit.bar);
                if (candleIndex === -1) return;

                const x = chartPadding.left + candleIndex * candleSpacing + candleSpacing / 2;
                const candle = candles[candleIndex];
                const price = exit.price || candle.close;
                
                if (!isFinite(price)) return;
                
                const priceY = chartPadding.top + ((maxPrice + pricePadding - price) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                if (!isFinite(x) || !isFinite(priceY)) return;

                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(x, priceY, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#0f1419';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw trend boundary lines
            trends.forEach(trend => {
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                const endIdx = candles.findIndex(c => c.bar === trend.endBar);
                if (startIdx === -1 || endIdx === -1) return;

                // Skip drawing lines for FLAT trends
                if (trend.type === 'FLAT') return;

                const color = trend.type === 'LONG' ? '#10b981' : '#ef4444';
                
                // Start line
                const startX = chartPadding.left + startIdx * candleSpacing;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(startX, chartPadding.top);
                ctx.lineTo(startX, canvas.height - chartPadding.bottom);
                ctx.stroke();

                // End line
                const endX = chartPadding.left + (endIdx + 1) * candleSpacing;
                ctx.beginPath();
                ctx.moveTo(endX, chartPadding.top);
                ctx.lineTo(endX, canvas.height - chartPadding.bottom);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label at top
                if (isFinite(startX) && isFinite(chartPadding.top)) {
                    ctx.fillStyle = color;
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    const label = trend.type === 'LONG' ? 'â–² LONG' : 'â–¼ SHORT';
                    ctx.fillText(label, startX + 5, chartPadding.top - 10);
                    
                    // Trend duration
                    const duration = trend.endBar - trend.startBar + 1;
                    ctx.font = '9px monospace';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText(`${duration} bars`, startX + 5, chartPadding.top - 22);
                }
            });

            // Draw FLAT trend labels (no lines, just labels)
            trends.forEach(trend => {
                if (trend.type !== 'FLAT') return;
                
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                if (startIdx === -1) return;

                const startX = chartPadding.left + startIdx * candleSpacing;
                
                // Label at top
                if (isFinite(startX) && isFinite(chartPadding.top)) {
                    ctx.fillStyle = '#9ca3af'; // Gray color for FLAT
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('â€” FLAT', startX + 5, chartPadding.top - 10);
                    
                    // Trend duration
                    const duration = trend.endBar - trend.startBar + 1;
                    ctx.font = '9px monospace';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText(`${duration} bars`, startX + 5, chartPadding.top - 22);
                }
            });

            // Draw bar numbers on x-axis
            ctx.fillStyle = '#9ca3af';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const labelEvery = Math.max(1, Math.floor(candles.length / 20));
            candles.forEach((candle, index) => {
                if (index % labelEvery === 0 || index === candles.length - 1) {
                    const x = chartPadding.left + index * candleSpacing + candleSpacing / 2;
                    if (isFinite(x) && isFinite(candle.bar)) {
                        ctx.fillText(candle.bar, x, canvas.height - chartPadding.bottom + 20);
                    }
                }
            });



            canvas.onmouseleave = function() {
                tooltip.classList.remove('show');
                isDragging = false;
            };
            
            // Restore canvas transform after drawing
            ctx.restore();

            // Mouse wheel zoom (vertical)
            canvas.onwheel = function(e) {
                e.preventDefault();
                const zoomSpeed = 0.1;
                if (e.deltaY < 0) {
                    priceZoom *= (1 + zoomSpeed); // Zoom in (stretch)
                } else {
                    priceZoom *= (1 - zoomSpeed); // Zoom out (compress)
                }
                priceZoom = Math.max(0.1, Math.min(10, priceZoom)); // Limit zoom range
                drawChart();
            };

            // Click and drag vertical zoom
            canvas.onmousedown = function(e) {
                isDragging = true;
                dragStartY = e.clientY;
                dragStartX = e.clientX;
            };

            canvas.onmouseup = function() {
                isDragging = false;
            };

            canvas.onmousemove = function(e) {
                if (isDragging) {
                    const deltaY = e.clientY - dragStartY;
                    const deltaX = e.clientX - dragStartX;
                    
                    // Only apply vertical pan if significant vertical movement
                    if (Math.abs(deltaY) > Math.abs(deltaX)) {
                        // Vertical panning (up/down) - VERY LESS sensitive and INVERTED
                        const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
                        const zoomedRange = (maxPriceRaw / priceZoom);
                        const priceShift = (deltaY / chartHeight) * zoomedRange * 0.02; // Inverted sign, much less sensitive
                        priceOffset += priceShift;
                        dragStartY = e.clientY;
                    } else {
                        // Horizontal panning (left/right) - MORE sensitive
                        const panSpeed = 0.1; // Increased from 0.02
                        const candlesToMove = -deltaX * panSpeed;
                        candleOffset += candlesToMove;
                        
                        // Clamp to valid range
                        candleOffset = Math.max(0, Math.min(candles.length - 1, candleOffset));
                        dragStartX = e.clientX;
                    }
                    
                    drawChart();
                } else {
                    // Show tooltip only when not dragging
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
                    const candleSpacing = chartWidth / candles.length;

                    const candleIndex = Math.floor((mouseX - chartPadding.left) / candleSpacing) + Math.floor(candleOffset);
                    if (candleIndex >= 0 && candleIndex < candles.length) {
                        const candle = candles[candleIndex];
                        showTooltip(candle, candleIndex, e.clientX, e.clientY);
                    } else {
                        tooltip.classList.remove('show');
                    }
                }
            };
            } catch (error) {
                console.error('Error drawing chart:', error);
                // Display error message on canvas
                if (ctx) {
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '14px monospace';
                    ctx.fillText('Error drawing chart. Check console for details.', 20, 50);
                }
            }
        }

        function showTooltip(candle, index, clientX, clientY) {
            const entryAtBar = entries.find(e => e.bar === candle.bar);
            const exitAtBar = exits.find(e => e.bar === candle.bar);

            let html = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Bar:</span>
                    <span class="tooltip-value">${candle.bar}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Time:</span>
                    <span class="tooltip-value">${candle.timestamp || 'N/A'}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Open:</span>
                    <span class="tooltip-value">${candle.open.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">High:</span>
                    <span class="tooltip-value">${candle.high.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Low:</span>
                    <span class="tooltip-value">${candle.low.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Close:</span>
                    <span class="tooltip-value">${candle.close.toFixed(2)}</span>
                </div>
            `;

            if (entryAtBar) {
                html += `
                    <div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #374151; padding-top: 6px;">
                        <span class="tooltip-label">Entry:</span>
                        <span class="tooltip-value" style="color: ${entryAtBar.direction === 'LONG' ? '#10b981' : '#ef4444'};">${entryAtBar.direction}</span>
                    </div>
                `;
            }

            if (exitAtBar) {
                html += `
                    <div class="tooltip-row" style="margin-top: 4px;">
                        <span class="tooltip-label">Exit:</span>
                        <span class="tooltip-value" style="color: #f59e0b;">Yes</span>
                    </div>
                `;
            }

            tooltip.innerHTML = html;
            tooltip.style.left = (clientX + 15) + 'px';
            tooltip.style.top = (clientY - 100) + 'px';
            tooltip.classList.add('show');
        }

        // Auto-resize chart
        window.addEventListener('resize', () => {
            if (candles.length > 0) {
                drawChart();
            }
        });
    </script>
</body>
</html>
