<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candle Chart - Strategy Logs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #1a1f3a 0%, #2d3561 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        input[type="file"] {
            padding: 8px;
            background: #1a1f3a;
            border: 1px solid #374151;
            border-radius: 5px;
            color: #e0e0e0;
            cursor: pointer;
        }

        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: #2563eb;
        }

        .stats {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-card {
            background: #1a1f3a;
            padding: 12px 16px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            min-width: 120px;
        }

        .stat-label {
            font-size: 11px;
            color: #9ca3af;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #60a5fa;
        }

        .chart-container {
            background: #1a1f3a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            overflow-x: auto;
            position: relative;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .tooltip {
            position: absolute;
            background: rgba(26, 31, 58, 0.95);
            border: 1px solid #60a5fa;
            border-radius: 5px;
            padding: 10px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            font-size: 12px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tooltip.show {
            display: block;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-bottom: 3px;
        }

        .tooltip-label {
            color: #9ca3af;
        }

        .tooltip-value {
            color: #e0e0e0;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #9ca3af;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #fca5a5;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-size: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .long-entry { background: #10b981; }
        .short-entry { background: #ef4444; }
        .exit { background: #f59e0b; }

        /* Pattern Analysis Styles */
        .analysis-controls input[type="checkbox"] {
            margin-right: 5px;
            transform: scale(1.2);
        }

        .analysis-controls label {
            color: #e0e0e0;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
        }

        .analysis-controls label:hover {
            color: #60a5fa;
        }

        .analysis-group {
            padding: 10px;
            background: rgba(31, 41, 55, 0.6);
            border-radius: 6px;
        }

        .pattern-marker {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        .trend-line {
            stroke: #60a5fa;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            opacity: 0.8;
        }

        .support-line {
            stroke: #10b981;
            stroke-width: 2;
            opacity: 0.7;
        }

        .resistance-line {
            stroke: #ef4444;
            stroke-width: 2;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìä Candle Chart from Strategy Logs</h1>
        <p>Upload a CSV file from strategy_logs to visualize price action and trades</p>
        
        <div class="controls">
            <input type="file" id="fileInput" accept=".csv" />
            <button onclick="loadFromServer()">Load Latest from Server</button>
            <span id="status" style="color: #9ca3af; font-size: 12px;"></span>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: #10b981; border: 2px solid #10b981;"></div>
                <span>Bullish Candle</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #ef4444; border: 2px solid #ef4444;"></div>
                <span>Bearish Candle</span>
            </div>
            <div class="legend-item">
                <div class="legend-box long-entry"></div>
                <span>LONG Entry</span>
            </div>
            <div class="legend-item">
                <div class="legend-box short-entry"></div>
                <span>SHORT Entry</span>
            </div>
            <div class="legend-item">
                <div class="legend-box exit"></div>
                <span>Exit</span>
            </div>
        </div>

        <!-- Pattern Analysis Controls -->
        <div class="analysis-controls" style="margin-top: 15px; padding: 15px; background: rgba(26, 31, 58, 0.8); border-radius: 8px;">
            <h3 style="color: #60a5fa; margin-bottom: 10px;">üìà Pattern Analysis</h3>
            <div style="margin-bottom: 15px; text-align: center;">
                <button id="selectAll" style="margin-right: 10px; padding: 6px 12px; font-size: 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">Select All</button>
                <button id="selectNone" style="padding: 6px 12px; font-size: 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Select None</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                <!-- Trend Detection -->
                <div class="analysis-group">
                    <label style="color: #10b981; font-weight: bold;">üîç Trend Detection</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableTrendDetection" checked> Enable Trend Lines</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableSupportResistance" checked> Support/Resistance</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableBreakouts"> Breakout Detection</label>
                </div>

                <!-- Candlestick Patterns -->
                <div class="analysis-group">
                    <label style="color: #f59e0b; font-weight: bold;">üïØÔ∏è Candlestick Patterns</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableEngulfing"> Engulfing Patterns</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableDoji"> Doji Patterns</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableHammer"> Hammer/Shooting Star</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableThreeSoldiers"> Three Soldiers/Crows</label>
                </div>

                <!-- Volume & Momentum -->
                <div class="analysis-group">
                    <label style="color: #8b5cf6; font-weight: bold;">üìä Volume & Momentum</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableVolumeSpikes"> Volume Spikes</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableMomentumDivergence"> Price Divergence</label>
                    <label style="display: block; margin: 5px 0;"><input type="checkbox" id="enableMovingAverages"> Moving Averages</label>
                </div>
            </div>

            <div style="display: flex; gap: 10px; align-items: center;">
                <button onclick="runPatternAnalysis()" style="background: #10b981;">üîç Analyze Patterns</button>
                <button onclick="clearPatternOverlays()" style="background: #6b7280;">Clear Overlays</button>
                <span id="patternStats" style="color: #9ca3af; font-size: 12px; margin-left: 10px;"></span>
            </div>
        </div>
    </div>

    <div style="margin: 20px; display: flex; align-items: center; gap: 15px;">
        <label style="color: #9ca3af; font-weight: 500;">Timeframe:</label>
        <select id="timeframe" style="background: #1f2937; color: #e5e7eb; border: 1px solid #374151; padding: 8px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
            <option value="1">Raw Data (as recorded)</option>
            <option value="30">30 seconds</option>
            <option value="60">1 minute</option>
            <option value="120">2 minutes</option>
            <option value="300">5 minutes</option>
            <option value="600">10 minutes</option>
            <option value="900">15 minutes</option>
            <option value="1800">30 minutes</option>
            <option value="3600">1 hour</option>
        </select>
    </div>

    <div class="stats" id="stats" style="display: none;">
        <div class="stat-card">
            <div class="stat-label">Total Bars</div>
            <div class="stat-value" id="stat-bars">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">LONG Entries</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">SHORT Entries</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Exits</div>
            <div class="stat-value" style="color: #f59e0b;" id="stat-exits">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Price Range</div>
            <div class="stat-value" id="stat-range">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #10b981;">
            <div class="stat-label">LONG Trends</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long-trends">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #ef4444;">
            <div class="stat-label">SHORT Trends</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short-trends">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #8b5cf6;">
            <div class="stat-label">Total Patterns</div>
            <div class="stat-value" style="color: #8b5cf6;" id="stat-total-patterns">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #10b981;">
            <div class="stat-label">LONG Patterns</div>
            <div class="stat-value" style="color: #10b981;" id="stat-long-patterns">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #ef4444;">
            <div class="stat-label">SHORT Patterns</div>
            <div class="stat-value" style="color: #ef4444;" id="stat-short-patterns">0</div>
        </div>
        <div class="stat-card" style="border-left-color: #f59e0b;">
            <div class="stat-label">FLAT Patterns</div>
            <div class="stat-value" style="color: #f59e0b;" id="stat-flat-patterns">0</div>
        </div>
    </div>

    <div class="chart-container">
        <canvas id="chartCanvas"></canvas>
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        let rawCandles = []; // Original data
        let rawEntries = [];
        let rawExits = [];
        let candles = []; // Aggregated data for display
        let entries = [];
        let exits = [];
        let trends = [];
        let ctx, tooltip;
        let priceZoom = 1.0; // Vertical zoom factor for price axis
        let priceOffset = 0; // Vertical pan offset (in price units)
        let isDragging = false;
        let dragStartY = 0;
        let dragStartX = 0;
        let candleOffset = 0; // Horizontal scroll offset (in candles)
        let chartPadding = { top: 40, right: 80, bottom: 40, left: 80 };

        // Pattern Analysis Variables
        let detectedPatterns = [];
        let trendLines = [];
        let supportResistanceLevels = [];
        let patternDirections = { LONG: 0, SHORT: 0, FLAT: 0 };
        let patternOverlaysEnabled = false;

        // Trend Analysis Functions
        function analyzeTrendDirection(currentIndex, lookback) {
            if (currentIndex < lookback) return 'FLAT';
            
            const startIdx = currentIndex - lookback;
            const endIdx = currentIndex;
            
            // Calculate price momentum
            const startPrice = (candles[startIdx].high + candles[startIdx].low + candles[startIdx].close) / 3;
            const endPrice = (candles[endIdx].high + candles[endIdx].low + candles[endIdx].close) / 3;
            const priceChange = (endPrice - startPrice) / startPrice;
            
            // Calculate moving average slope
            const prices = candles.slice(startIdx, endIdx + 1).map(c => c.close);
            const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
            const slope = calculateLinearRegression(prices).slope;
            
            // Analyze volume confirmation (if available)
            let volumeConfirmation = 0;
            if (candles[endIdx].volume && candles[startIdx].volume) {
                const recentVolume = candles.slice(Math.max(0, endIdx - 3), endIdx + 1)
                    .reduce((sum, c) => sum + (c.volume || 0), 0) / 4;
                const earlierVolume = candles.slice(Math.max(0, startIdx - 3), startIdx + 1)
                    .reduce((sum, c) => sum + (c.volume || 0), 0) / 4;
                volumeConfirmation = recentVolume > earlierVolume ? 1 : -0.5;
            }
            
            // Decision logic
            const trendThreshold = 0.002; // 0.2% price change threshold
            const slopeThreshold = 0.1;
            
            if (priceChange > trendThreshold && slope > slopeThreshold) {
                return 'LONG';
            } else if (priceChange < -trendThreshold && slope < -slopeThreshold) {
                return 'SHORT';
            } else {
                return 'FLAT';
            }
        }
        
        function calculateLinearRegression(values) {
            const n = values.length;
            const x = Array.from({length: n}, (_, i) => i);
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        function calculateTrendStrength(startIdx, endIdx) {
            const length = endIdx - startIdx + 1;
            const priceStart = candles[startIdx].close;
            const priceEnd = candles[endIdx].close;
            const priceChange = Math.abs(priceEnd - priceStart) / priceStart;
            
            // Strength based on price change magnitude and trend length
            return Math.min(priceChange * 100 + length / 10, 10);
        }

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('timeframe').addEventListener('change', function() {
            if (rawCandles.length > 0) {
                aggregateCandles();
                generateRealTrends();
                updateStats();
                drawChart();
            }
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('status').textContent = 'Reading file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parseCSV(e.target.result);
                    document.getElementById('status').textContent = `Loaded: ${file.name}`;
                } catch (error) {
                    document.getElementById('status').innerHTML = `<span style="color: #ef4444;">Error: ${error.message}</span>`;
                }
            };
            reader.readAsText(file);
        }

        async function loadFromServer() {
            document.getElementById('status').textContent = 'Loading from server...';
            try {
                // Try to get latest CSV from server
                const response = await fetch('/logs/latest-csv');
                if (!response.ok) throw new Error(`Server returned ${response.status}`);
                
                const csvText = await response.text();
                const filename = response.headers.get('X-Log-Filename') || 'latest csv';
                parseCSV(csvText);
                document.getElementById('status').textContent = `Loaded from server: ${filename}`;
            } catch (error) {
                document.getElementById('status').innerHTML = `<span style="color: #ef4444;">Error: ${error.message}</span>`;
            }
        }

        function parseCSV(csvText) {
            // Reset previously loaded data so uploads don't accumulate
            rawCandles = [];
            rawEntries = [];
            rawExits = [];
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) throw new Error('CSV file is empty or invalid');

            // Parse header
            const header = lines[0].split(',').map(h => h.trim());
            const barCol = header.indexOf('Bar');
            const timestampCol = header.indexOf('Timestamp');

            // Find OHLC columns (they might have different names)
            const openCol = header.findIndex(h => h.toLowerCase().includes('open'));
            const highCol = header.findIndex(h => h.toLowerCase().includes('high'));
            const lowCol = header.findIndex(h => h.toLowerCase().includes('low'));
            const closeCol = header.findIndex(h => h.toLowerCase().includes('close'));
            const pnlCol = header.indexOf('PNL');
            const candleTypeCol = header.indexOf('CandleType');

            candles = [];
            entries = [];
            exits = [];
            const candleByBar = new Map();

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const cols = line.split(',').map(c => c.trim());
                
                const bar = parseInt(cols[barCol]) || i;
                const timestamp = cols[timestampCol] || '';

                // Extract OHLC if available
                const open = parseFloat(cols[openCol]) || null;
                const high = parseFloat(cols[highCol]) || null;
                const low = parseFloat(cols[lowCol]) || null;
                const close = parseFloat(cols[closeCol]) || null;
                const pnl = pnlCol >= 0 ? parseFloat(cols[pnlCol]) || 0 : null;
                const candleType = candleTypeCol >= 0 ? cols[candleTypeCol] || '' : '';

                // Store candle data if we have price info
                if (open !== null && high !== null && low !== null && close !== null) {
                    candleByBar.set(bar, { bar, timestamp, open, high, low, close, pnl, candleType });
                }
            }

            rawCandles = Array.from(candleByBar.values())
                .map(c => ({ bar: c.bar, timestamp: c.timestamp, open: c.open, high: c.high, low: c.low, close: c.close, pnl: c.pnl, candleType: c.candleType }))
                .sort((a, b) => a.bar - b.bar);

            if (rawCandles.length === 0) {
                throw new Error('No valid candle data found in CSV. Make sure the file has Open, High, Low, Close columns.');
            }

            // Initial aggregation
            aggregateCandles();

            // Generate real trends based on market analysis
            generateRealTrends();

            updateStats();
            drawChart();
        }

        function aggregateCandles() {
            const timeframeSeconds = parseInt(document.getElementById('timeframe').value);
            
            if (timeframeSeconds === 1) {
                // No aggregation - use raw data
                candles = [...rawCandles].sort((a, b) => a.bar - b.bar);
                entries = [...rawEntries];
                exits = [...rawExits];
                return;
            }

            // Parse timestamps and group by timeframe
            candles = [];
            const candleMap = new Map();

            rawCandles.forEach(candle => {
                // Parse timestamp - format: MM/dd/yyyy HH:mm:ss
                const date = new Date(candle.timestamp);
                if (isNaN(date.getTime())) {
                    console.warn('Invalid timestamp:', candle.timestamp);
                    return;
                }

                // Round down to nearest timeframe interval
                const intervalStart = Math.floor(date.getTime() / 1000 / timeframeSeconds) * timeframeSeconds;
                const key = intervalStart.toString();

                if (!candleMap.has(key)) {
                    candleMap.set(key, {
                        timestamp: new Date(intervalStart * 1000).toLocaleString(),
                        open: candle.open,
                        high: candle.high,
                        low: candle.low,
                        close: candle.close,
                        bars: [candle.bar],
                        pnlSum: candle.pnl || 0,
                        candleTypes: [candle.candleType || '']
                    });
                } else {
                    const agg = candleMap.get(key);
                    agg.high = Math.max(agg.high, candle.high);
                    agg.low = Math.min(agg.low, candle.low);
                    agg.close = candle.close; // Last close in period
                    agg.bars.push(candle.bar);
                    agg.pnlSum += (candle.pnl || 0);
                    agg.candleTypes.push(candle.candleType || '');
                }
            });

            // Convert map to array and assign bar numbers
            let barNum = 0;
            const sortedKeys = Array.from(candleMap.keys()).sort((a, b) => parseInt(a) - parseInt(b));
            sortedKeys.forEach(key => {
                const agg = candleMap.get(key);
                // Calculate aggregated PNL and determine dominant candle type
                const aggPnl = agg.close - agg.open; // Aggregated candle's PNL
                const typeCount = agg.candleTypes.reduce((count, type) => {
                    count[type] = (count[type] || 0) + 1;
                    return count;
                }, {});
                const dominantType = Object.keys(typeCount).reduce((a, b) => typeCount[a] > typeCount[b] ? a : b) || '';
                
                candles.push({
                    bar: barNum++,
                    timestamp: agg.timestamp,
                    open: agg.open,
                    high: agg.high,
                    low: agg.low,
                    close: agg.close,
                    pnl: aggPnl,
                    candleType: dominantType,
                    originalBars: agg.bars,
                    originalPnlSum: agg.pnlSum
                });
            });

            // Map entries and exits to aggregated bars
            entries = rawEntries.map(entry => {
                const aggregatedCandle = candles.find(c => c.originalBars.includes(entry.bar));
                return aggregatedCandle ? { ...entry, bar: aggregatedCandle.bar } : null;
            }).filter(e => e !== null);

            exits = rawExits.map(exit => {
                const aggregatedCandle = candles.find(c => c.originalBars.includes(exit.bar));
                return aggregatedCandle ? { ...exit, bar: aggregatedCandle.bar } : null;
            }).filter(e => e !== null);
        }
        function generateRealTrends() {
            // Real trend analysis based on market data
            trends = [];
            if (candles.length < 20) return; // Need minimum data for trend analysis
            
            let currentTrend = null;
            let trendStartIdx = 0;
            const lookbackPeriod = 10; // Number of bars to analyze for trend direction
            const minTrendLength = 5;  // Minimum bars to confirm a trend
            
            for (let i = lookbackPeriod; i < candles.length; i++) {
                const trendDirection = analyzeTrendDirection(i, lookbackPeriod);
                
                // If trend changes or we're starting
                if (currentTrend === null || currentTrend !== trendDirection) {
                    // Save previous trend if it was long enough
                    if (currentTrend !== null && (i - trendStartIdx) >= minTrendLength) {
                        trends.push({
                            type: currentTrend,
                            startBar: candles[trendStartIdx].bar,
                            endBar: candles[i - 1].bar,
                            startIdx: trendStartIdx,
                            endIdx: i - 1,
                            strength: calculateTrendStrength(trendStartIdx, i - 1)
                        });
                    }
                    
                    // Start new trend
                    currentTrend = trendDirection;
                    trendStartIdx = i;
                }
            }
            
            // Add final trend
            if (currentTrend !== null && (candles.length - trendStartIdx) >= minTrendLength) {
                trends.push({
                    type: currentTrend,
                    startBar: candles[trendStartIdx].bar,
                    endBar: candles[candles.length - 1].bar,
                    startIdx: trendStartIdx,
                    endIdx: candles.length - 1,
                    strength: calculateTrendStrength(trendStartIdx, candles.length - 1)
                });
            }
            
            console.log(`Generated ${trends.length} real trends based on market analysis:`, trends);
        }

        // Trend Analysis Functions
        function analyzeTrendDirection(currentIndex, lookback) {
            if (currentIndex < lookback) return 'FLAT';
            
            const startIdx = currentIndex - lookback;
            const endIdx = currentIndex;
            
            // Calculate price momentum
            const startPrice = (candles[startIdx].high + candles[startIdx].low + candles[startIdx].close) / 3;
            const endPrice = (candles[endIdx].high + candles[endIdx].low + candles[endIdx].close) / 3;
            const priceChange = (endPrice - startPrice) / startPrice;
            
            // Calculate moving average slope
            const prices = candles.slice(startIdx, endIdx + 1).map(c => c.close);
            const slope = calculateLinearRegression(prices).slope;
            
            // Decision logic
            const trendThreshold = 0.001; // 0.1% price change threshold
            const slopeThreshold = 0.05;
            
            if (priceChange > trendThreshold && slope > slopeThreshold) {
                return 'LONG';
            } else if (priceChange < -trendThreshold && slope < -slopeThreshold) {
                return 'SHORT';
            } else {
                return 'FLAT';
            }
        }
        
        function calculateLinearRegression(values) {
            const n = values.length;
            const x = Array.from({length: n}, (_, i) => i);
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        function calculateTrendStrength(startIdx, endIdx) {
            const length = endIdx - startIdx + 1;
            const priceStart = candles[startIdx].close;
            const priceEnd = candles[endIdx].close;
            const priceChange = Math.abs(priceEnd - priceStart) / priceStart;
            
            // Strength based on price change magnitude and trend length
            return Math.min(priceChange * 100 + length / 10, 10);
        }        function calculateEMA(prices, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            // Start with SMA for first value
            let sum = 0;
            for (let i = 0; i < period && i < prices.length; i++) {
                sum += prices[i];
                ema.push(i < period - 1 ? null : sum / period);
            }
            
            // Calculate EMA for rest
            for (let i = period; i < prices.length; i++) {
                const prevEMA = ema[i - 1] || ema.find(v => v !== null);
                ema.push((prices[i] - prevEMA) * multiplier + prevEMA);
            }
            
            return ema;
        }

        function updateStats() {
            document.getElementById('stats').style.display = 'flex';
            document.getElementById('stat-bars').textContent = candles.length;
            
            // Hide entry/exit stats since we're not using them anymore
            const entryStats = document.getElementById('stat-long');
            const shortStats = document.getElementById('stat-short');
            const exitStats = document.getElementById('stat-exits');
            if (entryStats) entryStats.parentElement.style.display = 'none';
            if (shortStats) shortStats.parentElement.style.display = 'none';
            if (exitStats) exitStats.parentElement.style.display = 'none';
            
            // Show trend stats with strength analysis
            const longTrends = trends.filter(t => t.type === 'LONG');
            const shortTrends = trends.filter(t => t.type === 'SHORT');
            const flatTrends = trends.filter(t => t.type === 'FLAT');
            
            const avgLongStrength = longTrends.length > 0 ? 
                (longTrends.reduce((sum, t) => sum + (t.strength || 0), 0) / longTrends.length).toFixed(1) : '0.0';
            const avgShortStrength = shortTrends.length > 0 ? 
                (shortTrends.reduce((sum, t) => sum + (t.strength || 0), 0) / shortTrends.length).toFixed(1) : '0.0';
            
            document.getElementById('stat-long-trends').textContent = `${longTrends.length} (${avgLongStrength})`;
            document.getElementById('stat-short-trends').textContent = `${shortTrends.length} (${avgShortStrength})`;

            if (candles.length > 0) {
                const allPrices = candles.flatMap(c => [c.high, c.low]);
                const min = Math.min(...allPrices);
                const max = Math.max(...allPrices);
                document.getElementById('stat-range').textContent = `${min.toFixed(2)} - ${max.toFixed(2)}`;
            }
        }

        // =============================================
        // PATTERN ANALYSIS FUNCTIONS
        // =============================================

        function getPatternDirection(patternType) {
            // Bullish patterns suggest LONG positions
            const bullishPatterns = ['BULLISH_ENGULFING', 'HAMMER', 'DOJI_DRAGONFLY', 
                                   'THREE_WHITE_SOLDIERS', 'GOLDEN_CROSS', 'UPTREND', 
                                   'BULLISH_MOMENTUM_DIVERGENCE', 'VOLUME_BREAKOUT_UP'];
            
            // Bearish patterns suggest SHORT positions
            const bearishPatterns = ['BEARISH_ENGULFING', 'SHOOTING_STAR', 'DOJI_GRAVESTONE',
                                   'THREE_BLACK_CROWS', 'DEATH_CROSS', 'DOWNTREND',
                                   'BEARISH_MOMENTUM_DIVERGENCE', 'VOLUME_BREAKOUT_DOWN'];
            
            // Neutral patterns suggest FLAT (no position)
            const neutralPatterns = ['DOJI', 'VOLUME_SPIKE', 'SUPPORT', 'RESISTANCE', 'SIDEWAYS'];
            
            if (bullishPatterns.includes(patternType)) return 'LONG';
            if (bearishPatterns.includes(patternType)) return 'SHORT';
            return 'FLAT';
        }

        function runPatternAnalysis() {
            if (!candles || candles.length === 0) {
                alert('Please load candle data first');
                return;
            }

            console.log('üîç Starting pattern analysis...');
            detectedPatterns = [];
            trendLines = [];
            supportResistanceLevels = [];
            patternDirections = { LONG: 0, SHORT: 0, FLAT: 0 };

            // Run enabled analyses
            if (document.getElementById('enableTrendDetection')?.checked) {
                try {
                    analyzetrends();
                } catch (error) {
                    console.error('Error in trend analysis:', error);
                }
            }
            
            if (document.getElementById('enableSupportResistance')?.checked) {
                try {
                    analyzeSupportResistance();
                } catch (error) {
                    console.error('Error in support/resistance analysis:', error);
                }
            }
            
            if (document.getElementById('enableBreakouts')?.checked) {
                try {
                    analyzeBreakouts();
                } catch (error) {
                    console.error('Error in breakout detection:', error);
                }
            }
            
            if (document.getElementById('enableEngulfing').checked) {
                detectEngulfingPatterns();
            }
            
            if (document.getElementById('enableDoji').checked) {
                detectDojiPatterns();
            }
            
            if (document.getElementById('enableHammer').checked) {
                detectHammerPatterns();
            }
            
            if (document.getElementById('enableThreeSoldiers').checked) {
                detectThreeSoldiersPatterns();
            }
            
            if (document.getElementById('enableVolumeSpikes').checked) {
                analyzeVolumeSpikes();
            }
            
            if (document.getElementById('enableMomentumDivergence').checked) {
                analyzeMomentumDivergence();
            }
            
            if (document.getElementById('enableMovingAverages').checked) {
                analyzeMovingAverages();
            }

            patternOverlaysEnabled = true;
            updatePatternStats();
            drawChart(); // Redraw with patterns
            console.log(`‚úÖ Analysis complete: ${detectedPatterns.length} patterns detected`);
        }

        function clearPatternOverlays() {
            detectedPatterns = [];
            trendLines = [];
            supportResistanceLevels = [];
            patternOverlaysEnabled = false;
            updatePatternStats();
            drawChart(); // Redraw without patterns
        }

        function updatePatternStats() {
            const stats = document.getElementById('patternStats');
            if (detectedPatterns.length === 0) {
                stats.textContent = 'No patterns detected';
                return;
            }

            const patternCounts = {};
            detectedPatterns.forEach(p => {
                patternCounts[p.type] = (patternCounts[p.type] || 0) + 1;
            });

            const summaryText = Object.entries(patternCounts)
                .map(([type, count]) => `${type}: ${count}`)
                .join(' | ');
            stats.textContent = `Detected: ${summaryText}`;
        }

        // =============================================
        // TREND ANALYSIS
        // =============================================

        function analyzetrends() {
            if (!candles || candles.length < 30) {
                console.log('Not enough candle data for trend analysis');
                return;
            }
            const lookback = 20;
            for (let i = lookback; i < candles.length - 5; i++) {
                const segment = candles.slice(i - lookback, i + 5);
                
                // Detect uptrends (higher lows and higher highs)
                if (detectHigherLowsAndHighs(segment)) {
                    trendLines.push({
                        type: 'UPTREND',
                        startIdx: i - lookback,
                        endIdx: i + 5,
                        strength: calculateTrendStrength(segment, 'up')
                    });
                }
                
                // Detect downtrends (lower highs and lower lows)
                if (detectLowerHighsAndLows(segment)) {
                    trendLines.push({
                        type: 'DOWNTREND',
                        startIdx: i - lookback,
                        endIdx: i + 5,
                        strength: calculateTrendStrength(segment, 'down')
                    });
                }
            }
        }

        function detectHigherLowsAndHighs(segment) {
            if (!segment || !Array.isArray(segment) || segment.length < 4) {
                return false;
            }
            const highs = segment.map(c => c.high);
            const lows = segment.map(c => c.low);
            const midPoint = Math.floor(segment.length / 2);
            
            const firstHalfHighs = highs.slice(0, midPoint);
            const secondHalfHighs = highs.slice(midPoint);
            const firstHalfLows = lows.slice(0, midPoint);
            const secondHalfLows = lows.slice(midPoint);
            
            const avgFirstHigh = firstHalfHighs.reduce((a, b) => a + b, 0) / firstHalfHighs.length;
            const avgSecondHigh = secondHalfHighs.reduce((a, b) => a + b, 0) / secondHalfHighs.length;
            const avgFirstLow = firstHalfLows.reduce((a, b) => a + b, 0) / firstHalfLows.length;
            const avgSecondLow = secondHalfLows.reduce((a, b) => a + b, 0) / secondHalfLows.length;
            
            return avgSecondHigh > avgFirstHigh && avgSecondLow > avgFirstLow;
        }

        function detectLowerHighsAndLows(segment) {
            if (!segment || !Array.isArray(segment) || segment.length < 4) {
                return false;
            }
            const highs = segment.map(c => c.high);
            const lows = segment.map(c => c.low);
            const midPoint = Math.floor(segment.length / 2);
            
            const firstHalfHighs = highs.slice(0, midPoint);
            const secondHalfHighs = highs.slice(midPoint);
            const firstHalfLows = lows.slice(0, midPoint);
            const secondHalfLows = lows.slice(midPoint);
            
            const avgFirstHigh = firstHalfHighs.reduce((a, b) => a + b, 0) / firstHalfHighs.length;
            const avgSecondHigh = secondHalfHighs.reduce((a, b) => a + b, 0) / secondHalfHighs.length;
            const avgFirstLow = firstHalfLows.reduce((a, b) => a + b, 0) / firstHalfLows.length;
            const avgSecondLow = secondHalfLows.reduce((a, b) => a + b, 0) / secondHalfLows.length;
            
            return avgSecondHigh < avgFirstHigh && avgSecondLow < avgFirstLow;
        }

        function calculateTrendStrength(segment, direction) {
            if (!segment || !Array.isArray(segment) || segment.length < 2) {
                return 0;
            }
            const prices = segment.map(c => c.close);
            let strength = 0;
            
            for (let i = 1; i < prices.length; i++) {
                if (direction === 'up' && prices[i] > prices[i-1]) strength++;
                if (direction === 'down' && prices[i] < prices[i-1]) strength++;
            }
            
            return strength / (prices.length - 1);
        }

        // =============================================
        // SUPPORT/RESISTANCE ANALYSIS
        // =============================================

        function analyzeSupportResistance() {
            const allPrices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceStep = (maxPrice - minPrice) / 50; // 50 levels

            for (let level = minPrice; level <= maxPrice; level += priceStep) {
                const touches = countPriceTouches(level, priceStep / 2);
                
                if (touches >= 3) { // Minimum 3 touches for valid level
                    const isSupport = isLevelSupport(level);
                    supportResistanceLevels.push({
                        price: level,
                        type: isSupport ? 'SUPPORT' : 'RESISTANCE',
                        strength: touches,
                        tested: touches
                    });
                }
            }
        }

        function countPriceTouches(level, tolerance) {
            let touches = 0;
            candles.forEach(candle => {
                if (Math.abs(candle.low - level) <= tolerance || 
                    Math.abs(candle.high - level) <= tolerance) {
                    touches++;
                }
            });
            return touches;
        }

        function isLevelSupport(level) {
            let bounces = 0;
            let breaks = 0;
            
            candles.forEach((candle, i) => {
                if (i === 0) return;
                
                const prevCandle = candles[i-1];
                if (candle.low <= level && candle.close > level && prevCandle.close > level) {
                    bounces++;
                }
                if (candle.close < level && prevCandle.close >= level) {
                    breaks++;
                }
            });
            
            return bounces > breaks;
        }

        // =============================================
        // CANDLESTICK PATTERN DETECTION
        // =============================================

        function detectEngulfingPatterns() {
            for (let i = 1; i < candles.length; i++) {
                const current = candles[i];
                const previous = candles[i-1];
                
                // Bullish Engulfing
                if (isBearish(previous) && isBullish(current) &&
                    current.open < previous.close && current.close > previous.open) {
                    const pattern = {
                        type: 'BULLISH_ENGULFING',
                        barIndex: i,
                        confidence: calculateEngulfingConfidence(current, previous),
                        candle: current,
                        direction: 'LONG'
                    };
                    detectedPatterns.push(pattern);
                    patternDirections.LONG++;
                }
                
                // Bearish Engulfing
                if (isBullish(previous) && isBearish(current) &&
                    current.open > previous.close && current.close < previous.open) {
                    const pattern = {
                        type: 'BEARISH_ENGULFING',
                        barIndex: i,
                        confidence: calculateEngulfingConfidence(current, previous),
                        candle: current,
                        direction: 'SHORT'
                    };
                    detectedPatterns.push(pattern);
                    patternDirections.SHORT++;
                }
            }
        }

        function detectDojiPatterns() {
            candles.forEach((candle, i) => {
                if (isDoji(candle)) {
                    const context = getMarketContext(i);
                    const patternType = 'DOJI';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: calculateDojiConfidence(candle, context),
                        context: context,
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
            });
        }

        function detectHammerPatterns() {
            candles.forEach((candle, i) => {
                const bodySize = Math.abs(candle.close - candle.open);
                const totalRange = candle.high - candle.low;
                const upperShadow = candle.high - Math.max(candle.open, candle.close);
                const lowerShadow = Math.min(candle.open, candle.close) - candle.low;
                
                // Hammer: small body, long lower shadow, short upper shadow
                if (bodySize < totalRange * 0.3 && lowerShadow > bodySize * 2 && upperShadow < bodySize * 0.5) {
                    const patternType = 'HAMMER';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: calculateHammerConfidence(candle),
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
                
                // Shooting Star: small body, long upper shadow, short lower shadow
                if (bodySize < totalRange * 0.3 && upperShadow > bodySize * 2 && lowerShadow < bodySize * 0.5) {
                    const patternType = 'SHOOTING_STAR';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: calculateHammerConfidence(candle),
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
            });
        }

        function detectThreeSoldiersPatterns() {
            for (let i = 2; i < candles.length; i++) {
                const c1 = candles[i-2];
                const c2 = candles[i-1];
                const c3 = candles[i];
                
                // Three White Soldiers
                if (isBullish(c1) && isBullish(c2) && isBullish(c3) &&
                    c2.close > c1.close && c3.close > c2.close &&
                    c2.open > c1.open && c2.open < c1.close &&
                    c3.open > c2.open && c3.open < c2.close) {
                    const patternType = 'THREE_WHITE_SOLDIERS';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: 0.8,
                        candle: c3,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
                
                // Three Black Crows
                if (isBearish(c1) && isBearish(c2) && isBearish(c3) &&
                    c2.close < c1.close && c3.close < c2.close &&
                    c2.open < c1.open && c2.open > c1.close &&
                    c3.open < c2.open && c3.open > c2.close) {
                    const patternType = 'THREE_BLACK_CROWS';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: 0.8,
                        candle: c3,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                }
            }
        }

        // =============================================
        // VOLUME & MOMENTUM ANALYSIS
        // =============================================

        function analyzeVolumeSpikes() {
            // Check if any candles have volume data
            const hasVolumeData = candles.some(c => c.volume && c.volume > 0);
            if (!hasVolumeData) {
                console.log('No volume data found in candles');
                return;
            }
            
            const volumes = candles.map(c => c.volume || 0);
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            console.log(`Volume analysis: avg=${avgVolume.toFixed(0)}, threshold=${(avgVolume * 2).toFixed(0)}`);
            
            let spikesFound = 0;
            candles.forEach((candle, i) => {
                if (candle.volume && candle.volume > avgVolume * 1.5) { // Lower threshold for more sensitivity
                    const patternType = 'VOLUME_SPIKE';
                    const direction = getPatternDirection(patternType);
                    const pattern = {
                        type: patternType,
                        barIndex: i,
                        confidence: Math.min(candle.volume / avgVolume / 3, 1.0),
                        volumeRatio: candle.volume / avgVolume,
                        candle: candle,
                        direction: direction
                    };
                    detectedPatterns.push(pattern);
                    patternDirections[direction]++;
                    spikesFound++;
                }
            });
            console.log(`Volume spikes found: ${spikesFound}`);
        }

        function analyzeMomentumDivergence() {
            // Price vs momentum divergence detection
            const lookback = 14;
            for (let i = lookback; i < candles.length - lookback; i++) {
                const priceChange = candles[i].close - candles[i - lookback].close;
                const futureChange = candles[i + lookback].close - candles[i].close;
                
                // Bullish divergence: price making lower lows but momentum improving
                if (priceChange < 0 && futureChange > Math.abs(priceChange) * 0.5) {
                    detectedPatterns.push({
                        type: 'BULLISH_DIVERGENCE',
                        barIndex: i,
                        confidence: Math.min(Math.abs(futureChange / priceChange), 1.0),
                        candle: candles[i]
                    });
                }
            }
        }

        function analyzeMovingAverages() {
            const shortMA = calculateSMA(9);
            const longMA = calculateSMA(21);
            
            for (let i = 21; i < candles.length; i++) {
                const shortCurrent = shortMA[i];
                const shortPrevious = shortMA[i-1];
                const longCurrent = longMA[i];
                const longPrevious = longMA[i-1];
                
                // Golden Cross (bullish)
                if (shortPrevious <= longPrevious && shortCurrent > longCurrent) {
                    detectedPatterns.push({
                        type: 'GOLDEN_CROSS',
                        barIndex: i,
                        confidence: 0.7,
                        candle: candles[i]
                    });
                }
                
                // Death Cross (bearish)
                if (shortPrevious >= longPrevious && shortCurrent < longCurrent) {
                    detectedPatterns.push({
                        type: 'DEATH_CROSS',
                        barIndex: i,
                        confidence: 0.7,
                        candle: candles[i]
                    });
                }
            }
        }

        // =============================================
        // BREAKOUT ANALYSIS
        // =============================================

        function analyzeBreakouts() {
            supportResistanceLevels.forEach(level => {
                candles.forEach((candle, i) => {
                    if (level.type === 'RESISTANCE' && candle.close > level.price && candles[i-1]?.close <= level.price) {
                        detectedPatterns.push({
                            type: 'RESISTANCE_BREAKOUT',
                            barIndex: i,
                            confidence: Math.min(level.strength / 10, 1.0),
                            level: level.price,
                            candle: candle
                        });
                    }
                    
                    if (level.type === 'SUPPORT' && candle.close < level.price && candles[i-1]?.close >= level.price) {
                        detectedPatterns.push({
                            type: 'SUPPORT_BREAKDOWN',
                            barIndex: i,
                            confidence: Math.min(level.strength / 10, 1.0),
                            level: level.price,
                            candle: candle
                        });
                    }
                });
            });
        }

        // =============================================
        // UTILITY FUNCTIONS
        // =============================================

        function isBullish(candle) { return candle.close > candle.open; }
        function isBearish(candle) { return candle.close < candle.open; }
        function isDoji(candle) {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalRange = candle.high - candle.low;
            return bodySize < totalRange * 0.1;
        }

        function calculateSMA(period) {
            const sma = [];
            for (let i = 0; i < candles.length; i++) {
                if (i < period - 1) {
                    sma.push(null);
                } else {
                    let sum = 0;
                    for (let j = i - period + 1; j <= i; j++) {
                        sum += candles[j].close;
                    }
                    sma.push(sum / period);
                }
            }
            return sma;
        }

        function calculateEngulfingConfidence(current, previous) {
            const currentBody = Math.abs(current.close - current.open);
            const previousBody = Math.abs(previous.close - previous.open);
            return Math.min(currentBody / previousBody / 2, 1.0);
        }

        function calculateDojiConfidence(candle, context) {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalRange = candle.high - candle.low;
            return 1 - (bodySize / totalRange);
        }

        function calculateHammerConfidence(candle) {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalRange = candle.high - candle.low;
            return 1 - (bodySize / totalRange);
        }

        function getMarketContext(index) {
            if (index < 5) return 'INSUFFICIENT_DATA';
            const recent = candles.slice(index - 5, index);
            const avgClose = recent.reduce((sum, c) => sum + c.close, 0) / recent.length;
            return candles[index].close > avgClose ? 'UPTREND_CONTEXT' : 'DOWNTREND_CONTEXT';
        }

        function drawChart() {
            try {
                canvas = document.getElementById('chartCanvas');
                
                if (!candles || candles.length === 0) {
                    console.error('No candles to draw');
                    return;
                }

                // Set canvas size FIRST to reset any error state
                const container = canvas.parentElement;
                const idealWidth = Math.max(container.clientWidth - 40, candles.length * 12);
                const maxCanvasWidth = 32000; // Browser limit is typically 32767
                const newWidth = Math.min(idealWidth, maxCanvasWidth);
                const newHeight = 600;
                
                console.log(`Canvas sizing: candles=${candles.length}, idealWidth=${idealWidth}, newWidth=${newWidth}`);
                
                // Validate dimensions before applying
                if (!isFinite(newWidth) || !isFinite(newHeight) || newWidth <= 0 || newHeight <= 0) {
                    console.error('Invalid canvas dimensions:', newWidth, newHeight);
                    return;
                }
                
                // Setting dimensions clears canvas and resets context
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // Get fresh context after resizing
                ctx = canvas.getContext('2d');
                tooltip = document.getElementById('tooltip');
                
                if (!ctx) {
                    console.error('Failed to get canvas context');
                    return;
                }

            // Calculate price range with zoom
            const allPrices = candles.flatMap(c => [c.high, c.low]).filter(p => isFinite(p));
            if (allPrices.length === 0) {
                console.error('No valid prices found');
                return;
            }
            
            const minPriceRaw = Math.min(...allPrices);
            const maxPriceRaw = Math.max(...allPrices);
            const priceCenter = (minPriceRaw + maxPriceRaw) / 2;
            const priceRangeRaw = maxPriceRaw - minPriceRaw;
            
            // Apply zoom by scaling around the center
            const zoomedRange = priceRangeRaw / priceZoom;
            let minPrice = priceCenter - zoomedRange / 2 + priceOffset;
            let maxPrice = priceCenter + zoomedRange / 2 + priceOffset;
            const pricePadding = zoomedRange * 0.1;

            if (!isFinite(minPrice) || !isFinite(maxPrice) || zoomedRange <= 0) {
                console.error('Invalid price range:', minPrice, maxPrice, zoomedRange);
                return;
            }

            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const candleWidth = Math.max(6, Math.min(20, chartWidth / candles.length * 0.7));
            const candleSpacing = chartWidth / candles.length;

            // Validate critical dimensions
            if (!isFinite(candleSpacing) || candleSpacing <= 0) {
                console.error('Invalid candleSpacing:', candleSpacing, 'chartWidth:', chartWidth, 'candles.length:', candles.length);
                throw new Error('Invalid chart dimensions');
            }
            if (!isFinite(chartHeight) || chartHeight <= 0) {
                console.error('Invalid chartHeight:', chartHeight);
                throw new Error('Invalid chart height');
            }

            // Clear canvas
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply horizontal pan offset by translating canvas
            const panPixels = candleOffset * candleSpacing;
            ctx.save();
            ctx.translate(-panPixels, 0);

            // Draw trend background zones FIRST (behind everything)
            console.log('About to draw', trends.length, 'trend backgrounds');
            console.log('candleSpacing:', candleSpacing, 'chartHeight:', chartHeight, 'chartPadding:', chartPadding);
            trends.forEach((trend, trendIdx) => {
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                const endIdx = candles.findIndex(c => c.bar === trend.endBar);
                if (startIdx === -1 || endIdx === -1) {
                    console.warn(`Trend ${trendIdx}: bars not found`, trend);
                    return;
                }

                const startX = chartPadding.left + startIdx * candleSpacing;
                const endX = chartPadding.left + (endIdx + 1) * candleSpacing;
                const width = endX - startX;

                console.log(`Trend ${trendIdx}: startX=${startX}, endX=${endX}, width=${width}`);

                // Validate coordinates before drawing
                if (!isFinite(startX) || !isFinite(endX) || !isFinite(width) || 
                    !isFinite(chartPadding.top) || !isFinite(chartHeight) ||
                    width <= 0 || chartHeight <= 0) {
                    console.warn('Skipping trend with invalid coordinates:', trend, {startX, endX, width, chartHeight});
                    return;
                }

                // Color based on trend type with strength-based opacity
                const strength = trend.strength || 1;
                const baseOpacity = Math.min(0.08 + (strength / 50), 0.25);
                
                if (trend.type === 'LONG') {
                    ctx.fillStyle = `rgba(16, 185, 129, ${baseOpacity})`;
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                } else if (trend.type === 'SHORT') {
                    ctx.fillStyle = `rgba(239, 68, 68, ${baseOpacity})`;
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                } else {
                    ctx.fillStyle = `rgba(156, 163, 175, ${Math.max(baseOpacity - 0.05, 0.02)})`;
                    ctx.fillRect(startX, chartPadding.top, width, chartHeight);
                }
                
                // Add trend label with strength
                if (width > 60) { // Only show label if trend is wide enough
                    ctx.fillStyle = trend.type === 'LONG' ? '#10b981' : 
                                   trend.type === 'SHORT' ? '#ef4444' : '#9ca3af';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    const labelX = startX + width / 2;
                    const labelY = chartPadding.top + 15;
                    ctx.fillText(`${trend.type}`, labelX, labelY);
                    
                    // Show strength if significant
                    if (trend.strength && trend.strength > 1) {
                        ctx.font = '8px monospace';
                        ctx.fillText(`(${trend.strength.toFixed(1)})`, labelX, labelY + 12);
                    }
                }
                
                console.log(`Trend ${trendIdx}: drew successfully`);
            });

            // Draw grid
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines (price levels)
            const numPriceLines = 8;
            console.log('Drawing', numPriceLines, 'horizontal grid lines');
            for (let i = 0; i <= numPriceLines; i++) {
                const y = chartPadding.top + (chartHeight / numPriceLines) * i;
                
                // Validate grid line coordinates
                if (!isFinite(y) || !isFinite(chartPadding.left) || !isFinite(canvas.width) || !isFinite(chartPadding.right)) {
                    console.warn(`Skipping grid line ${i} with invalid coordinates: y=${y}, left=${chartPadding.left}, width=${canvas.width}, right=${chartPadding.right}`);
                    continue;
                }
                
                const x1 = chartPadding.left;
                const x2 = canvas.width - chartPadding.right;
                console.log(`Grid line ${i}: y=${y}, x1=${x1}, x2=${x2}`);
                
                if (!isFinite(x1) || !isFinite(x2)) {
                    console.warn(`Grid line ${i} has invalid x coordinates: x1=${x1}, x2=${x2}`);
                    continue;
                }
                
                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();

                // Price labels
                const price = maxPrice + pricePadding - ((maxPrice - minPrice + 2 * pricePadding) / numPriceLines) * i;
                if (isFinite(price) && isFinite(y)) {
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '11px monospace';
                    ctx.textAlign = 'right';
                    ctx.fillText(price.toFixed(2), chartPadding.left - 10, y + 4);
                }
            }

            // Draw candles
            candles.forEach((candle, index) => {
                // Validate candle data
                if (!candle || !isFinite(candle.open) || !isFinite(candle.high) || 
                    !isFinite(candle.low) || !isFinite(candle.close)) {
                    console.warn(`Skipping invalid candle at index ${index}:`, candle);
                    return;
                }
                
                const x = chartPadding.left + index * candleSpacing + candleSpacing / 2;
                
                const openY = chartPadding.top + ((maxPrice + pricePadding - candle.open) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const closeY = chartPadding.top + ((maxPrice + pricePadding - candle.close) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const highY = chartPadding.top + ((maxPrice + pricePadding - candle.high) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;
                const lowY = chartPadding.top + ((maxPrice + pricePadding - candle.low) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                // Validate all calculated coordinates
                if (!isFinite(x) || !isFinite(openY) || !isFinite(closeY) || 
                    !isFinite(highY) || !isFinite(lowY)) {
                    console.warn(`Skipping candle with invalid coordinates at index ${index}`);
                    return;
                }

                const isBullish = candle.close > candle.open;
                ctx.fillStyle = isBullish ? '#10b981' : '#ef4444';
                ctx.strokeStyle = isBullish ? '#10b981' : '#ef4444';

                // Draw wick (high-low line)
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body (open-close rectangle)
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(2, Math.abs(closeY - openY));
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
            });

            // Draw entry markers
            entries.forEach(entry => {
                const candleIndex = candles.findIndex(c => c.bar === entry.bar);
                if (candleIndex === -1) return;

                const x = chartPadding.left + candleIndex * candleSpacing + candleSpacing / 2;
                const candle = candles[candleIndex];
                const price = entry.price || candle.close;
                
                if (!isFinite(price)) return;
                
                const priceY = chartPadding.top + ((maxPrice + pricePadding - price) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                if (!isFinite(x) || !isFinite(priceY)) return;

                ctx.fillStyle = entry.direction === 'LONG' ? '#10b981' : '#ef4444';
                ctx.beginPath();
                if (entry.direction === 'LONG') {
                    // Upward triangle for LONG
                    ctx.moveTo(x, priceY - 10);
                    ctx.lineTo(x - 6, priceY);
                    ctx.lineTo(x + 6, priceY);
                } else {
                    // Downward triangle for SHORT
                    ctx.moveTo(x, priceY + 10);
                    ctx.lineTo(x - 6, priceY);
                    ctx.lineTo(x + 6, priceY);
                }
                ctx.closePath();
                ctx.fill();
            });

            // Draw exit markers
            exits.forEach(exit => {
                const candleIndex = candles.findIndex(c => c.bar === exit.bar);
                if (candleIndex === -1) return;

                const x = chartPadding.left + candleIndex * candleSpacing + candleSpacing / 2;
                const candle = candles[candleIndex];
                const price = exit.price || candle.close;
                
                if (!isFinite(price)) return;
                
                const priceY = chartPadding.top + ((maxPrice + pricePadding - price) / (maxPrice - minPrice + 2 * pricePadding)) * chartHeight;

                if (!isFinite(x) || !isFinite(priceY)) return;

                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(x, priceY, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#0f1419';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw trend boundary lines
            trends.forEach(trend => {
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                const endIdx = candles.findIndex(c => c.bar === trend.endBar);
                if (startIdx === -1 || endIdx === -1) return;

                // Skip drawing lines for FLAT trends
                if (trend.type === 'FLAT') return;

                const color = trend.type === 'LONG' ? '#10b981' : '#ef4444';
                
                // Start line
                const startX = chartPadding.left + startIdx * candleSpacing;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(startX, chartPadding.top);
                ctx.lineTo(startX, canvas.height - chartPadding.bottom);
                ctx.stroke();

                // End line
                const endX = chartPadding.left + (endIdx + 1) * candleSpacing;
                ctx.beginPath();
                ctx.moveTo(endX, chartPadding.top);
                ctx.lineTo(endX, canvas.height - chartPadding.bottom);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label at top
                if (isFinite(startX) && isFinite(chartPadding.top)) {
                    ctx.fillStyle = color;
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    const label = trend.type === 'LONG' ? '‚ñ≤ LONG' : '‚ñº SHORT';
                    ctx.fillText(label, startX + 5, chartPadding.top - 10);
                    
                    // Trend duration
                    const duration = trend.endBar - trend.startBar + 1;
                    ctx.font = '9px monospace';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText(`${duration} bars`, startX + 5, chartPadding.top - 22);
                }
            });

            // Draw FLAT trend labels (no lines, just labels)
            trends.forEach(trend => {
                if (trend.type !== 'FLAT') return;
                
                const startIdx = candles.findIndex(c => c.bar === trend.startBar);
                if (startIdx === -1) return;

                const startX = chartPadding.left + startIdx * candleSpacing;
                
                // Label at top
                if (isFinite(startX) && isFinite(chartPadding.top)) {
                    ctx.fillStyle = '#9ca3af'; // Gray color for FLAT
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('‚Äî FLAT', startX + 5, chartPadding.top - 10);
                    
                    // Trend duration
                    const duration = trend.endBar - trend.startBar + 1;
                    ctx.font = '9px monospace';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText(`${duration} bars`, startX + 5, chartPadding.top - 22);
                }
            });

            // Draw timestamps on x-axis
            ctx.fillStyle = '#9ca3af';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const labelEvery = Math.max(1, Math.floor(candles.length / 20));
            candles.forEach((candle, index) => {
                if (index % labelEvery === 0 || index === candles.length - 1) {
                    const x = chartPadding.left + index * candleSpacing + candleSpacing / 2;
                    if (isFinite(x) && candle.timestamp) {
                        // Parse timestamp and format as local time
                        try {
                            const date = new Date(candle.timestamp);
                            const timeString = date.toLocaleTimeString('en-US', { 
                                hour12: false, 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            });
                            ctx.fillText(timeString, x, canvas.height - chartPadding.bottom + 20);
                        } catch (e) {
                            // Fallback to bar number if timestamp parsing fails
                            ctx.fillText(candle.bar || index, x, canvas.height - chartPadding.bottom + 20);
                        }
                    }
                }
            });



            canvas.onmouseleave = function() {
                tooltip.classList.remove('show');
                isDragging = false;
            };
            
            // Restore canvas transform after drawing
            ctx.restore();

            // =============================================
            // DRAW PATTERN OVERLAYS
            // =============================================
            if (patternOverlaysEnabled) {
                // Save context for overlay drawing
                ctx.save();
                ctx.translate(-panPixels, 0);

                // Draw trend lines
                drawTrendLines(candleSpacing, chartHeight, chartPadding, canvas, ctx);

                // Draw support/resistance levels
                drawSupportResistanceLevels(candleSpacing, chartHeight, chartPadding, canvas, ctx);

                // Draw pattern markers
                drawPatternMarkers(candleSpacing, chartHeight, chartPadding, canvas, ctx);

                // Restore context
                ctx.restore();
            }

            // Mouse wheel zoom (vertical)
            canvas.onwheel = function(e) {
                e.preventDefault();
                const zoomSpeed = 0.1;
                if (e.deltaY < 0) {
                    priceZoom *= (1 + zoomSpeed); // Zoom in (stretch)
                } else {
                    priceZoom *= (1 - zoomSpeed); // Zoom out (compress)
                }
                priceZoom = Math.max(0.1, Math.min(10, priceZoom)); // Limit zoom range
                drawChart();
            };

            // Click and drag vertical zoom
            canvas.onmousedown = function(e) {
                isDragging = true;
                dragStartY = e.clientY;
                dragStartX = e.clientX;
            };

            canvas.onmouseup = function() {
                isDragging = false;
            };

            canvas.onmousemove = function(e) {
                if (isDragging) {
                    const deltaY = e.clientY - dragStartY;
                    const deltaX = e.clientX - dragStartX;
                    
                    // Only apply vertical pan if significant vertical movement
                    if (Math.abs(deltaY) > Math.abs(deltaX)) {
                        // Vertical panning (up/down) - EXTREMELY LESS sensitive and INVERTED
                        const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;
                        const zoomedRange = (maxPriceRaw / priceZoom);
                        const priceShift = (deltaY / chartHeight) * zoomedRange * 0.005; // Much less sensitive (reduced from 0.02 to 0.005)
                        priceOffset += priceShift;
                        dragStartY = e.clientY;
                    } else {
                        // Horizontal panning (left/right) - MORE sensitive
                        const panSpeed = 0.1; // Increased from 0.02
                        const candlesToMove = -deltaX * panSpeed;
                        candleOffset += candlesToMove;
                        
                        // Simple clamp to valid range
                        candleOffset = Math.max(0, Math.min(candles.length - 1, candleOffset));
                        dragStartX = e.clientX;
                    }
                    
                    drawChart();
                } else {
                    // Show tooltip only when not dragging
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Check if mouse is within chart area
                    if (mouseX >= chartPadding.left && mouseX <= canvas.width - chartPadding.right) {
                        const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
                        const candleSpacing = chartWidth / candles.length;
                        
                        // Account for panning offset when calculating candle index
                        const panPixels = candleOffset * candleSpacing;
                        const adjustedMouseX = mouseX + panPixels;
                        const candleIndex = Math.floor((adjustedMouseX - chartPadding.left) / candleSpacing);
                        
                        if (candleIndex >= 0 && candleIndex < candles.length) {
                            const candle = candles[candleIndex];
                            showTooltip(candle, candleIndex, e.clientX, e.clientY);
                        } else {
                            tooltip.classList.remove('show');
                        }
                    } else {
                        tooltip.classList.remove('show');
                    }
                }
            };
            } catch (error) {
                console.error('Error drawing chart:', error);
                // Display error message on canvas
                if (ctx) {
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '14px monospace';
                    ctx.fillText('Error drawing chart. Check console for details.', 20, 50);
                }
            }
        }

        // =============================================
        // PATTERN OVERLAY DRAWING FUNCTIONS
        // =============================================

        function drawTrendLines(candleSpacing, chartHeight, chartPadding, canvas, ctx) {
            if (!document.getElementById('enableTrendDetection').checked) return;

            trendLines.forEach(trend => {
                if (trend.startIdx < 0 || trend.endIdx >= candles.length) return;

                // Use consistent spacing calculation that matches main chart
                const startX = chartPadding.left + trend.startIdx * candleSpacing + candleSpacing / 2;
                const endX = chartPadding.left + trend.endIdx * candleSpacing + candleSpacing / 2;
                
                const startCandle = candles[trend.startIdx];
                const endCandle = candles[trend.endIdx];
                const minPrice = Math.min(...candles.map(c => c.low));
                const maxPrice = Math.max(...candles.map(c => c.high));
                const priceRange = maxPrice - minPrice;

                let startY, endY;
                if (trend.type === 'UPTREND') {
                    startY = chartPadding.top + ((maxPrice - startCandle.low) / priceRange) * chartHeight;
                    endY = chartPadding.top + ((maxPrice - endCandle.high) / priceRange) * chartHeight;
                    ctx.strokeStyle = '#10b981';
                } else {
                    startY = chartPadding.top + ((maxPrice - startCandle.high) / priceRange) * chartHeight;
                    endY = chartPadding.top + ((maxPrice - endCandle.low) / priceRange) * chartHeight;
                    ctx.strokeStyle = '#ef4444';
                }

                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.globalAlpha = 0.7;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = 'bold 10px monospace';
                ctx.fillText(trend.type, (startX + endX) / 2, (startY + endY) / 2 - 10);
                
                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;
            });
        }

        function drawSupportResistanceLevels(candleSpacing, chartHeight, chartPadding, canvas, ctx) {
            if (!document.getElementById('enableSupportResistance').checked) return;

            const allPrices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice;

            supportResistanceLevels.forEach(level => {
                const y = chartPadding.top + ((maxPrice - level.price) / priceRange) * chartHeight;
                
                if (level.type === 'SUPPORT') {
                    ctx.strokeStyle = '#10b981';
                } else {
                    ctx.strokeStyle = '#ef4444';
                }
                
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                ctx.setLineDash([3, 3]);
                
                ctx.beginPath();
                ctx.moveTo(chartPadding.left, y);
                ctx.lineTo(canvas.width - chartPadding.right, y);
                ctx.stroke();
                
                // Label with strength
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = '10px monospace';
                ctx.fillText(`${level.type} ${level.price.toFixed(2)} (${level.strength}x)`, 
                           chartPadding.left + 5, y - 5);
                
                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;
            });
        }

        function drawPatternMarkers(candleSpacing, chartHeight, chartPadding, canvas, ctx) {
            const allPrices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice;

            detectedPatterns.forEach(pattern => {
                if (pattern.barIndex < 0 || pattern.barIndex >= candles.length) return;

                // Use consistent spacing calculation that matches main chart
                const x = chartPadding.left + pattern.barIndex * candleSpacing + candleSpacing / 2;
                const candle = pattern.candle;
                let y = chartPadding.top + ((maxPrice - candle.high) / priceRange) * chartHeight - 20;

                // Choose marker style and color based on pattern type
                let color = '#60a5fa';
                let symbol = '‚óè';
                let size = 8;

                if (pattern.type.includes('BULLISH') || pattern.type.includes('GOLDEN') || pattern.type.includes('WHITE')) {
                    color = '#10b981';
                    symbol = '‚ñ≤';
                } else if (pattern.type.includes('BEARISH') || pattern.type.includes('DEATH') || pattern.type.includes('BLACK')) {
                    color = '#ef4444';
                    symbol = '‚ñº';
                } else if (pattern.type.includes('DOJI')) {
                    color = '#f59e0b';
                    symbol = '‚óÜ';
                } else if (pattern.type.includes('HAMMER')) {
                    color = '#8b5cf6';
                    symbol = 'üî®';
                    size = 12;
                } else if (pattern.type.includes('VOLUME')) {
                    color = '#06b6d4';
                    symbol = 'üìä';
                    size = 14; // Make volume spikes more prominent
                }

                // Draw marker background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, size + 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw marker
                ctx.fillStyle = color;
                ctx.font = `${size}px monospace`;
                ctx.textAlign = 'center';
                ctx.fillText(symbol, x, y + size/3);

                // Draw pattern label
                ctx.fillStyle = color;
                ctx.font = 'bold 9px monospace';
                ctx.textAlign = 'center';
                const label = pattern.type.replace(/_/g, ' ');
                ctx.fillText(label, x, y - size - 5);

                // Draw confidence indicator
                if (pattern.confidence) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '8px monospace';
                    ctx.fillText(`${(pattern.confidence * 100).toFixed(0)}%`, x, y + size + 12);
                }
            });
        }

        function showTooltip(candle, index, clientX, clientY) {
            const entryAtBar = entries.find(e => e.bar === candle.bar);
            const exitAtBar = exits.find(e => e.bar === candle.bar);
            const patternsAtBar = detectedPatterns.filter(p => p.barIndex === index);

            let html = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Bar:</span>
                    <span class="tooltip-value">${candle.bar}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Time:</span>
                    <span class="tooltip-value">${candle.timestamp || 'N/A'}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Open:</span>
                    <span class="tooltip-value">${candle.open.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">High:</span>
                    <span class="tooltip-value">${candle.high.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Low:</span>
                    <span class="tooltip-value">${candle.low.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Close:</span>
                    <span class="tooltip-value">${candle.close.toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">PNL:</span>
                    <span class="tooltip-value" style="color: ${(candle.pnl || 0) >= 0 ? '#10b981' : '#ef4444'};">${(candle.pnl || 0).toFixed(2)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Candle:</span>
                    <span class="tooltip-value" style="color: ${candle.candleType === 'good' ? '#10b981' : candle.candleType === 'bad' ? '#ef4444' : '#9ca3af'};">${candle.candleType || 'N/A'}</span>
                </div>
            `;

            if (entryAtBar) {
                html += `
                    <div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #374151; padding-top: 6px;">
                        <span class="tooltip-label">Entry:</span>
                        <span class="tooltip-value" style="color: ${entryAtBar.direction === 'LONG' ? '#10b981' : '#ef4444'};">${entryAtBar.direction}</span>
                    </div>
                `;
            }

            if (exitAtBar) {
                html += `
                    <div class="tooltip-row" style="margin-top: 4px;">
                        <span class="tooltip-label">Exit:</span>
                        <span class="tooltip-value" style="color: #f59e0b;">Yes</span>
                    </div>
                `;
            }

            // Add pattern information
            if (patternsAtBar.length > 0) {
                html += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #374151; padding-top: 6px;">`;
                html += `<span class="tooltip-label">Patterns:</span>`;
                html += `</div>`;
                
                patternsAtBar.forEach(pattern => {
                    const confidence = pattern.confidence ? ` (${(pattern.confidence * 100).toFixed(0)}%)` : '';
                    let patternColor = '#60a5fa';
                    
                    if (pattern.type.includes('BULLISH') || pattern.type.includes('GOLDEN') || pattern.type.includes('WHITE')) {
                        patternColor = '#10b981';
                    } else if (pattern.type.includes('BEARISH') || pattern.type.includes('DEATH') || pattern.type.includes('BLACK')) {
                        patternColor = '#ef4444';
                    } else if (pattern.type.includes('DOJI')) {
                        patternColor = '#f59e0b';
                    }
                    
                    html += `
                        <div class="tooltip-row" style="margin-left: 12px;">
                            <span class="tooltip-value" style="color: ${patternColor};">‚Ä¢ ${pattern.type.replace(/_/g, ' ')}${confidence}</span>
                        </div>
                    `;
                });
            }

            tooltip.innerHTML = html;
            tooltip.style.left = (clientX + 15) + 'px';
            tooltip.style.top = (clientY - 100) + 'px';
            tooltip.classList.add('show');
        }

        // Add event listeners for analysis checkboxes and controls
        document.addEventListener('DOMContentLoaded', () => {
            const analysisCheckboxes = document.querySelectorAll('.analysis-controls input[type="checkbox"]');
            
            analysisCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    if (candles.length > 0) {
                        runPatternAnalysis();
                        drawChart();
                    }
                });
            });

            // Select All button
            document.getElementById('selectAll').addEventListener('click', () => {
                analysisCheckboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
                if (candles.length > 0) {
                    runPatternAnalysis();
                    drawChart();
                }
            });

            // Select None button
            document.getElementById('selectNone').addEventListener('click', () => {
                analysisCheckboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                if (candles.length > 0) {
                    runPatternAnalysis();
                    drawChart();
                }
            });
        });

        // Auto-resize chart
        window.addEventListener('resize', () => {
            if (candles.length > 0) {
                drawChart();
            }
        });
    </script>
</body>
</html>
