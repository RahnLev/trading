<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bar Debug - Trade Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: #2d2d2d;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .header h1 {
            font-size: 1.5rem;
            margin: 0;
        }
        .controls {
            padding: 15px 30px;
            background: #252525;
            border-bottom: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .filter-group input, .filter-group select {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 0.9rem;
        }
        .filter-group label {
            font-size: 0.9rem;
            color: #b0b0b0;
        }
        .table-container {
            overflow-x: auto;
            max-height: calc(100vh - 250px);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        thead {
            background: #252525;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        th {
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #fff;
            border-bottom: 2px solid #404040;
            white-space: nowrap;
        }
        td {
            padding: 10px 8px;
            border-bottom: 1px solid #333;
            white-space: nowrap;
        }
        tbody tr {
            transition: background 0.2s;
        }
        tbody tr:hover {
            background: #353535;
        }
        tbody tr.selected {
            background: #4a5568;
            border-left: 3px solid #667eea;
        }
        .bar-index {
            font-weight: 700;
            color: #667eea;
        }
        .direction-long {
            color: #10b981;
            font-weight: 700;
        }
        .direction-short {
            color: #ef4444;
            font-weight: 700;
        }
        .value-highest {
            color: #10b981 !important;
            font-weight: 700 !important;
        }
        .value-middle {
            color: #fbbf24 !important;
            font-weight: 700 !important;
        }
        .value-lowest {
            color: #ef4444 !important;
            font-weight: 700 !important;
        }
        .in-trade {
            background: rgba(79, 209, 197, 0.1);
        }
        .candle-good {
            color: #10b981;
        }
        .candle-bad {
            color: #ef4444;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        .error {
            text-align: center;
            padding: 40px;
            color: #ef4444;
        }
        .stats {
            display: flex;
            gap: 20px;
            padding: 15px 30px;
            background: #252525;
            border-bottom: 1px solid #404040;
            flex-wrap: wrap;
        }
        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #e0e0e0;
        }
        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .pagination button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        .pagination button:hover:not(:disabled) {
            background: #5568d3;
        }
        .pagination button:disabled {
            background: #4a4a4a;
            color: #888;
            cursor: not-allowed;
        }
        .pagination-info {
            color: #b0b0b0;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Bar Debug - Trade Analysis</h1>
            <div style="display: flex; gap: 10px; align-items: center;">
                <button onclick="loadBars()" style="background: white; color: #667eea; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: 600;">üîÑ Refresh</button>
                <label style="color: white; display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="autoRefresh" checked style="width: auto;">
                    <span>Auto-refresh (5s)</span>
                </label>
                <div style="display: flex; gap: 10px; align-items: center;">
                <a href="troubleshoot.html" class="back-btn" style="background: rgba(245, 158, 11, 0.3);">üîß Troubleshoot</a>
                <a href="table-viewer.html" class="back-btn">‚Üê Back to Tables</a>
            </div>
            </div>
        </div>
        
        <div class="stats" id="stats">
            <div class="stat-item">
                <span class="stat-label">Total Bars</span>
                <span class="stat-value" id="totalBars">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">API Total Rows</span>
                <span class="stat-value" id="apiTotalRows">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Bars in Trade</span>
                <span class="stat-value" id="barsInTrade">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Long Entries</span>
                <span class="stat-value" id="longEntries">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Short Entries</span>
                <span class="stat-value" id="shortEntries">-</span>
            </div>
        </div>

        <div class="controls">
            <div class="filter-group">
                <label>Bar Range:</label>
                <input type="number" id="barStart" placeholder="Start" min="0" style="width: 100px;">
                <span>-</span>
                <input type="number" id="barEnd" placeholder="End" min="0" style="width: 100px;">
                <button onclick="applyFilters()">Filter</button>
                <button onclick="clearFilters()">Clear</button>
            </div>
            <div class="filter-group">
                <label>Direction:</label>
                <select id="directionFilter">
                    <option value="">All</option>
                    <option value="LONG">Long</option>
                    <option value="SHORT">Short</option>
                    <option value="FLAT">Flat</option>
                </select>
                <label>In Trade:</label>
                <select id="inTradeFilter">
                    <option value="">All</option>
                    <option value="1">Yes</option>
                    <option value="0">No</option>
                </select>
            </div>
            <div class="filter-group" style="border-top: 1px solid #404040; padding-top: 10px; margin-top: 10px; width: 100%;">
                <label style="font-weight: 600;">Min Tick Gaps (for ‚úì/‚úó indicators):</label>
                <label>Min C‚ÜíF Ticks:</label>
                <input type="number" id="minTicksCloseToFast" placeholder="0" min="0" value="0" style="width: 60px;">
                <label>Min F‚ÜíS Ticks:</label>
                <input type="number" id="minTicksFastToSlow" placeholder="0" min="0" value="0" style="width: 60px;">
                <label style="margin-left: 15px; font-weight: 600;">Gradient Degree:</label>
                <label>Min (for Longs):</label>
                <input type="number" id="minGradientDeg" placeholder="0" step="0.1" value="0" style="width: 70px;">
                <label>Max (for Shorts):</label>
                <input type="number" id="maxGradientDeg" placeholder="0" step="0.1" value="0" style="width: 70px;">
                <button onclick="renderTable()">Update Indicators</button>
            </div>
            <div class="pagination">
                <button id="prevBtn" onclick="changePage(-1)">‚Üê Prev</button>
                <span class="pagination-info" id="pageInfo">Page 1</span>
                <button id="nextBtn" onclick="changePage(1)">Next ‚Üí</button>
            </div>
        </div>

        <div class="table-container">
            <div id="loading" class="loading">Loading bar data...</div>
            <div id="error" class="error" style="display: none;"></div>
            <table id="barTable" style="display: none;">
                <thead>
                    <tr>
                        <th>Bar Index</th>
                        <th>Timestamp</th>
                        <th>Open</th>
                        <th>High</th>
                        <th>Low</th>
                        <th>Close</th>
                        <th>EMA Fast Val</th>
                        <th>EMA Slow Val</th>
                        <th>C‚ÜíF Ticks</th>
                        <th>F‚ÜíS Ticks</th>
                        <th>Gradient Deg</th>
                        <th>Volume</th>
                        <th>Range</th>
                        <th>Body</th>
                        <th>Stop Loss</th>
                        <th>Trade</th>
                        <th style="min-width: 250px;">Entry/Exit Reason</th>
                        <th>Candle</th>
                        <th>Trend‚Üë</th>
                        <th>Trend‚Üì</th>
                        <th>Allow L</th>
                        <th>Allow S</th>
                        <th>Pending L</th>
                        <th>Pending S</th>
                        <th>Avoid L</th>
                        <th>Avoid S</th>
                        <th>EMA Fast</th>
                        <th>EMA Slow</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let allBars = [];
        let filteredBars = [];
        let tradesByBar = {}; // Map of bar_index -> {entry: trade, exit: trade}
        let activeTrades = {}; // Map of entry_bar -> trade (for tracking active trades)
        let currentPage = 0;
        const pageSize = 200;
        let autoRefreshInterval = null;
        let lastBarCount = 0;
        let lastTradeCount = 0;

        async function loadBars(isAutoRefresh = false) {
            let trades = []; // Declare trades at function scope
            try {
                // Only show loading spinner on manual refresh, not auto-refresh
                if (!isAutoRefresh) {
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('error').style.display = 'none';
                    document.getElementById('barTable').style.display = 'none';
                }

                // Check strategy state first to see if it's running
                let strategyState = null;
                try {
                    const stateResponse = await fetch('/api/strategy-state');
                    if (stateResponse.ok) {
                        strategyState = await stateResponse.json();
                        console.log('[BAR_DEBUG] Strategy state:', strategyState);
                    }
                } catch (stateError) {
                    console.warn('[BAR_DEBUG] Could not fetch strategy state:', stateError);
                }

                // Load bars and trades in parallel
                // Use a very large limit to get all bars (or remove limit entirely)
                const [barsResponse, tradesResponse] = await Promise.all([
                    fetch('/api/databases/table-data?database_name=volatility.db&table_name=bar_samples&limit=1000000'),
                    fetch('/api/databases/table-data?database_name=dashboard.db&table_name=trades&limit=1000000')
                ]);
                
                if (!barsResponse.ok) {
                    const errorText = await barsResponse.text();
                    throw new Error(`HTTP ${barsResponse.status}: ${errorText}`);
                }
                
                const barsData = await barsResponse.json();
                
                // Debug logging
                console.log('[BAR_DEBUG] API Response:', {
                    hasRows: !!barsData.rows,
                    rowsLength: barsData.rows ? barsData.rows.length : 0,
                    totalRows: barsData.total_rows,
                    keys: Object.keys(barsData)
                });
                
                // API returns: {rows: [...], columns: [...], total_rows: ...}
                if (barsData.rows && Array.isArray(barsData.rows)) {
                    allBars = barsData.rows;
                    console.log('[BAR_DEBUG] Loaded', allBars.length, 'bars from rows array');
                } else if (barsData.error) {
                    throw new Error(barsData.error);
                } else if (barsData.success && barsData.data) {
                    allBars = barsData.data;
                    console.log('[BAR_DEBUG] Loaded', allBars.length, 'bars from data array');
                } else if (Array.isArray(barsData)) {
                    allBars = barsData;
                    console.log('[BAR_DEBUG] Loaded', allBars.length, 'bars from direct array');
                } else {
                    console.error('[BAR_DEBUG] Unexpected format:', barsData);
                    throw new Error('Unexpected response format. Expected "rows" array. Got: ' + Object.keys(barsData).join(', '));
                }
                
                if (allBars.length === 0) {
                    console.warn('[BAR_DEBUG] No bars found after parsing');
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    let errorMsg = 'No bar data found in database. ';
                    
                    if (barsData.total_rows === 0) {
                        errorMsg += '\n\nPossible reasons:\n';
                        errorMsg += '1. Strategy is still running in historical mode (bars stored in memory, not database yet)\n';
                        errorMsg += '2. Strategy has not transitioned to real-time yet (bars are sent when transitioning)\n';
                        errorMsg += '3. Strategy is not running or not recording bar samples\n';
                        errorMsg += '4. Database was cleared\n\n';
                        
                        if (strategyState) {
                            if (strategyState._isStale) {
                                errorMsg += '‚ö† Strategy state file is stale (>5 min old) - strategy may have stopped.\n';
                            } else {
                                errorMsg += '‚Ñπ Strategy appears to be running (state file is recent).\n';
                            }
                        }
                        
                        errorMsg += '\nSOLUTION:\n';
                        errorMsg += '‚Ä¢ Wait for strategy to finish historical playback and transition to real-time\n';
                        errorMsg += '‚Ä¢ OR enable "RecordBarSamplesInHistorical" parameter in strategy settings\n';
                        errorMsg += '  (WARNING: May cause timeouts with large datasets)';
                    } else {
                        errorMsg += '\n\nAPI reports ' + barsData.total_rows + ' total rows but parsing returned 0 bars.\n';
                        errorMsg += 'Check browser console for detailed error messages.';
                    }
                    
                    document.getElementById('error').textContent = errorMsg;
                    document.getElementById('error').style.whiteSpace = 'pre-line'; // Allow line breaks
                    document.getElementById('error').style.textAlign = 'left';
                    document.getElementById('error').style.padding = '20px';
                    return;
                }
                
                console.log('[BAR_DEBUG] Successfully loaded', allBars.length, 'bars. Sample bar:', allBars[0]);
                console.log('[BAR_DEBUG] Total rows from API:', barsData.total_rows);
                console.log('[BAR_DEBUG] First few bar indices:', allBars.slice(0, 10).map(b => b.bar_index || b.barIndex));
                
                // If we got very few bars but API says there are more, try fetching more
                if (allBars.length < 100 && barsData.total_rows && barsData.total_rows > allBars.length) {
                    console.warn('[BAR_DEBUG] WARNING: Only', allBars.length, 'bars loaded but API reports', barsData.total_rows, 'total rows.');
                    console.warn('[BAR_DEBUG] This suggests a limit issue. Attempting to fetch more...');
                    
                    // Try fetching with offset to get more bars
                    try {
                        const moreBarsResponse = await fetch(`/api/databases/table-data?database_name=volatility.db&table_name=bar_samples&limit=1000000&offset=0`);
                        if (moreBarsResponse.ok) {
                            const moreBarsData = await moreBarsResponse.json();
                            if (moreBarsData.rows && Array.isArray(moreBarsData.rows) && moreBarsData.rows.length > allBars.length) {
                                console.log('[BAR_DEBUG] Successfully fetched', moreBarsData.rows.length, 'bars on retry');
                                allBars = moreBarsData.rows;
                            }
                        }
                    } catch (retryError) {
                        console.error('[BAR_DEBUG] Retry failed:', retryError);
                    }
                }
                
                // Check if we got fewer bars than expected
                const apiTotalRows = barsData.total_rows || 0;
                const loadedBars = allBars.length;
                
                if (loadedBars < 10) {
                    console.warn('[BAR_DEBUG] WARNING: Only', loadedBars, 'bars loaded.');
                    console.warn('[BAR_DEBUG] API reports total_rows:', apiTotalRows);
                    
                    if (apiTotalRows === loadedBars) {
                        console.warn('[BAR_DEBUG] Database has exactly', loadedBars, 'bars. This is normal if:');
                        console.warn('  - Strategy just started and only processed a few bars');
                        console.warn('  - Strategy is in real-time mode and only a few bars have occurred');
                        console.warn('  - Strategy is still in historical mode (bars stored in memory, not database)');
                    } else if (apiTotalRows > loadedBars) {
                        console.warn('[BAR_DEBUG] API reports', apiTotalRows, 'total rows but only', loadedBars, 'were loaded.');
                        console.warn('[BAR_DEBUG] This suggests a parsing or limit issue.');
                    } else {
                        console.warn('[BAR_DEBUG] Database has limited data. Check if strategy is running and recording bar samples.');
                    }
                } else {
                    console.log('[BAR_DEBUG] Successfully loaded', loadedBars, 'bars (API total:', apiTotalRows, ')');
                }
                
                // Load trades if available
                if (tradesResponse.ok) {
                    try {
                        const tradesData = await tradesResponse.json();
                        // Reset trades array
                        trades = [];
                        if (tradesData.rows && Array.isArray(tradesData.rows)) {
                            trades = tradesData.rows;
                        } else if (tradesData.success && tradesData.data) {
                            trades = tradesData.data;
                        } else if (Array.isArray(tradesData)) {
                            trades = tradesData;
                        }
                        
                        // Build map of trades by bar index and track active trades
                        tradesByBar = {};
                        activeTrades = {};
                        // Also store all trades for checking bars between entry and exit
                        const allTradesList = [];
                        
                        trades.forEach(trade => {
                            const entryBar = trade.entry_bar;
                            const exitBar = trade.exit_bar;
                            
                            // Store all trades for checking bars between entry and exit
                            if (entryBar !== null && entryBar !== undefined) {
                                allTradesList.push(trade);
                            }
                            
                            if (entryBar !== null && entryBar !== undefined) {
                                if (!tradesByBar[entryBar]) {
                                    tradesByBar[entryBar] = {entry: null, exit: null};
                                }
                                tradesByBar[entryBar].entry = trade;
                                
                                // Track as active trade ONLY if it doesn't have an exit yet (or exit is in the future)
                                // This means the trade is currently open
                                if (exitBar === null || exitBar === undefined) {
                                    activeTrades[entryBar] = trade;
                                    console.log('[BAR_DEBUG] Active trade found: Entry bar', entryBar, 'Direction:', trade.direction, '(no exit yet)');
                                }
                            }
                            
                            if (exitBar !== null && exitBar !== undefined) {
                                if (!tradesByBar[exitBar]) {
                                    tradesByBar[exitBar] = {entry: null, exit: null};
                                }
                                tradesByBar[exitBar].exit = trade;
                            }
                        });
                        
                        // Store all trades globally so we can check bars between entry and exit
                        window.allTradesList = allTradesList;
                        
                        console.log('[BAR_DEBUG] Loaded', trades.length, 'trades. Active trades (no exit):', Object.keys(activeTrades).length);
                    } catch (tradesError) {
                        console.warn('Failed to load trades:', tradesError);
                        // Continue without trades
                    }
                }
                
                // Display API total rows for debugging
                if (barsData.total_rows !== undefined) {
                    document.getElementById('apiTotalRows').textContent = barsData.total_rows;
                    
                    // Show a notice if we have very few bars
                    if (barsData.total_rows < 50 && allBars.length > 0) {
                        const noticeDiv = document.createElement('div');
                        noticeDiv.style.cssText = 'background: #f59e0b; color: white; padding: 10px; margin: 10px 0; border-radius: 4px;';
                        noticeDiv.innerHTML = `
                            <strong>‚ö† Limited Data:</strong> Only ${barsData.total_rows} bars in database. 
                            ${barsData.total_rows < 10 ? 'This is normal if the strategy just started or is still in historical mode.' : 'Consider waiting for more bars to accumulate or enable "RecordBarSamplesInHistorical" for historical data.'}
                        `;
                        document.querySelector('.stats').appendChild(noticeDiv);
                    }
                }
                
                // Check if we have new data
                const newBarCount = allBars.length;
                const newTradeCount = trades.length;
                const hasNewData = newBarCount !== lastBarCount || newTradeCount !== lastTradeCount;
                
                if (hasNewData && isAutoRefresh) {
                    console.log('[BAR_DEBUG] New data detected:', {
                        bars: `${lastBarCount} ‚Üí ${newBarCount}`,
                        trades: `${lastTradeCount} ‚Üí ${newTradeCount}`
                    });
                }
                
                lastBarCount = newBarCount;
                lastTradeCount = newTradeCount;
                
                allBars.sort((a, b) => (b.bar_index || 0) - (a.bar_index || 0));
                // Preserve current page during auto-refresh
                applyFilters(isAutoRefresh);
                updateStats();
                
                // Hide loading spinner if it was shown
                if (!isAutoRefresh) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('barTable').style.display = 'table';
                }
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error: ${error.message}`;
                console.error('Load bars error:', error);
            }
        }

        function updateStats() {
            const total = allBars.length;
            
            // Count bars in trade - use both in_trade field AND all trades
            let inTrade = 0;
            const tradesToCheck = window.allTradesList || [];
            
            allBars.forEach(bar => {
                let isInTrade = bar.in_trade == 1;
                
                // Also check if this bar is between entry and exit using ALL trades (not just active ones)
                if (!isInTrade) {
                    const currentBarNum = bar.bar_index;
                    
                    for (const trade of tradesToCheck) {
                        const entryBarNum = trade.entry_bar;
                        const exitBarNum = trade.exit_bar;
                        
                        if (entryBarNum !== null && entryBarNum !== undefined) {
                            // Bar is in trade if it's >= entry bar and (no exit yet or <= exit bar)
                            if (currentBarNum >= entryBarNum && (exitBarNum === null || exitBarNum === undefined || currentBarNum <= exitBarNum)) {
                                isInTrade = true;
                                break;
                            }
                        }
                    }
                }
                
                if (isInTrade) {
                    inTrade++;
                }
            });
            
            const longEntries = allBars.filter((b, i) => 
                i > 0 && b.direction === 'LONG' && allBars[i-1].direction !== 'LONG'
            ).length;
            const shortEntries = allBars.filter((b, i) => 
                i > 0 && b.direction === 'SHORT' && allBars[i-1].direction !== 'SHORT'
            ).length;

            document.getElementById('totalBars').textContent = total;
            document.getElementById('barsInTrade').textContent = inTrade;
            document.getElementById('longEntries').textContent = longEntries;
            document.getElementById('shortEntries').textContent = shortEntries;
        }

        function applyFilters(preservePage = false) {
            const barStart = document.getElementById('barStart').value;
            const barEnd = document.getElementById('barEnd').value;
            const direction = document.getElementById('directionFilter').value;
            const inTradeFilter = document.getElementById('inTradeFilter').value;

            // Store previous filtered count to check if filters changed
            const prevFilteredCount = filteredBars ? filteredBars.length : 0;

            filteredBars = allBars.filter(bar => {
                if (barStart && bar.bar_index < parseInt(barStart)) return false;
                if (barEnd && bar.bar_index > parseInt(barEnd)) return false;
                if (direction && bar.direction !== direction) return false;
                
                // Check in_trade status using both bar.in_trade field AND all trades
                if (inTradeFilter !== '') {
                    let isInTrade = bar.in_trade == 1;
                    
                    // Also check if this bar is between entry and exit using ALL trades (not just active ones)
                    if (!isInTrade) {
                        const currentBarNum = bar.bar_index;
                        const tradesToCheck = window.allTradesList || [];
                        
                        for (const trade of tradesToCheck) {
                            const entryBarNum = trade.entry_bar;
                            const exitBarNum = trade.exit_bar;
                            
                            if (entryBarNum !== null && entryBarNum !== undefined) {
                                // Bar is in trade if it's >= entry bar and (no exit yet or <= exit bar)
                                if (currentBarNum >= entryBarNum && (exitBarNum === null || exitBarNum === undefined || currentBarNum <= exitBarNum)) {
                                    isInTrade = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    const filterValue = parseInt(inTradeFilter);
                    if (filterValue === 1 && !isInTrade) return false;
                    if (filterValue === 0 && isInTrade) return false;
                }
                
                return true;
            });

            // Only reset page if filters actually changed (different count) or if not preserving page
            // During auto-refresh, preserve the current page if filter results are similar
            if (!preservePage || Math.abs(filteredBars.length - prevFilteredCount) > 10) {
                currentPage = 0;
            } else {
                // Ensure currentPage is still valid after filtering
                const maxPage = Math.ceil(filteredBars.length / pageSize) - 1;
                if (currentPage > maxPage) {
                    currentPage = Math.max(0, maxPage);
                }
            }
            
            renderTable();
        }

        function clearFilters() {
            document.getElementById('barStart').value = '';
            document.getElementById('barEnd').value = '';
            document.getElementById('directionFilter').value = '';
            document.getElementById('inTradeFilter').value = '';
            applyFilters();
        }

        function changePage(delta) {
            const maxPage = Math.ceil(filteredBars.length / pageSize) - 1;
            currentPage = Math.max(0, Math.min(maxPage, currentPage + delta));
            renderTable();
        }

        function renderTable() {
            const start = currentPage * pageSize;
            const end = start + pageSize;
            const pageBars = filteredBars.slice(start, end);

            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';

            pageBars.forEach(bar => {
                const row = document.createElement('tr');
                
                // Check if bar is in trade - use both bar.in_trade field AND all trades
                let isInTrade = bar.in_trade == 1;
                
                // Also check if this bar is between entry and exit using ALL trades (not just active ones)
                // This handles completed trades where bars between entry and exit should be marked as "in trade"
                if (!isInTrade) {
                    const currentBarNum = bar.bar_index;
                    
                    // Check all trades (including completed ones)
                    const tradesToCheck = window.allTradesList || [];
                    for (const trade of tradesToCheck) {
                        const entryBarNum = trade.entry_bar;
                        const exitBarNum = trade.exit_bar;
                        
                        if (entryBarNum !== null && entryBarNum !== undefined) {
                            // Bar is in trade if it's >= entry bar and (no exit yet or <= exit bar)
                            if (currentBarNum >= entryBarNum && (exitBarNum === null || exitBarNum === undefined || currentBarNum <= exitBarNum)) {
                                isInTrade = true;
                                break;
                            }
                        }
                    }
                }
                
                if (isInTrade) {
                    row.classList.add('in-trade');
                }

                // Set direction color: green for LONG, red for SHORT, default for FLAT
                const direction = bar.direction || 'FLAT';
                const directionClass = direction === 'LONG' ? 'direction-long' : 
                                     direction === 'SHORT' ? 'direction-short' : '';

                // Color code all three values (Close, EMA Fast, EMA Slow): green=highest, yellow=middle, red=lowest
                const close = parseFloat(bar.close_price);
                const open = parseFloat(bar.open_price);
                const emaFast = parseFloat(bar.ema_fast_value);
                const emaSlow = parseFloat(bar.ema_slow_value);
                
                // Determine candle body color: green for bullish (Close > Open), red for bearish (Close < Open)
                const isBullishCandle = !isNaN(close) && !isNaN(open) && close > open;
                const isBearishCandle = !isNaN(close) && !isNaN(open) && close < open;
                let bodyBgColor = '';
                let bodyTextColor = '#e0e0e0';
                if (isBullishCandle) {
                    bodyBgColor = 'background-color: #10b981; ';
                    bodyTextColor = '#ffffff';
                } else if (isBearishCandle) {
                    bodyBgColor = 'background-color: #ef4444; ';
                    bodyTextColor = '#ffffff';
                }
                
                // Build array of all three values (only include valid numbers)
                const allValues = [];
                if (!isNaN(close) && close !== null && close !== undefined) allValues.push({ val: Number(close), name: 'close' });
                if (!isNaN(emaFast) && emaFast !== null && emaFast !== undefined) allValues.push({ val: Number(emaFast), name: 'emaFast' });
                if (!isNaN(emaSlow) && emaSlow !== null && emaSlow !== undefined) allValues.push({ val: Number(emaSlow), name: 'emaSlow' });
                
                // Sort by value descending to determine highest, middle, lowest
                allValues.sort((a, b) => {
                    const diff = b.val - a.val;
                    // Handle floating point precision issues
                    return Math.abs(diff) < 0.0001 ? 0 : diff;
                });
                
                // Get color class for any of the three values (Close, EMA Fast, EMA Slow)
                const getValueClass = (val, name) => {
                    const numVal = Number(val);
                    if (isNaN(numVal) || numVal === null || numVal === undefined || allValues.length < 2) {
                        console.log(`[COLOR_TRACE] Bar ${bar.bar_index} ${name}: Invalid value or not enough values`, { val, numVal, allValuesLength: allValues.length });
                        return '';
                    }
                    
                    // Find the index of this value in the sorted array by name
                    const idx = allValues.findIndex(v => v.name === name);
                    if (idx === -1) {
                        console.log(`[COLOR_TRACE] Bar ${bar.bar_index} ${name}: Not found in allValues`, { val, name, allValues });
                        return '';
                    }
                    
                    // If only 2 values, highest is green, lowest is red
                    if (allValues.length === 2) {
                        const result = idx === 0 ? 'value-highest' : 'value-lowest';
                        console.log(`[COLOR_TRACE] Bar ${bar.bar_index} ${name}: 2 values, idx=${idx}, result=${result}`, { allValues, idx });
                        return result;
                    }
                    
                    // If 3 values: highest=green, middle=yellow, lowest=red
                    let result;
                    if (idx === 0) result = 'value-highest';
                    else if (idx === allValues.length - 1) result = 'value-lowest';
                    else result = 'value-middle';
                    
                    console.log(`[COLOR_TRACE] Bar ${bar.bar_index} ${name}: 3 values, idx=${idx}, result=${result}`, { 
                        allValues: allValues.map(v => `${v.name}=${v.val}`),
                        sortedOrder: allValues.map((v, i) => `${i}:${v.name}`).join(', '),
                        idx,
                        result
                    });
                    return result;
                };
                
                const closeClass = getValueClass(close, 'close');
                const emaFastClass = getValueClass(emaFast, 'emaFast');
                const emaSlowClass = getValueClass(emaSlow, 'emaSlow');
                
                // Build inline style strings for all three values with !important to override any CSS
                let closeStyle = '';
                if (closeClass) {
                    const color = closeClass === 'value-highest' ? '#10b981' : 
                                 closeClass === 'value-middle' ? '#fbbf24' : '#ef4444';
                    closeStyle = `style="color: ${color} !important; font-weight: 700 !important;"`;
                }
                
                let emaFastStyle = '';
                if (emaFastClass) {
                    const color = emaFastClass === 'value-highest' ? '#10b981' : 
                                 emaFastClass === 'value-middle' ? '#fbbf24' : '#ef4444';
                    emaFastStyle = `style="color: ${color} !important; font-weight: 700 !important;"`;
                }
                
                let emaSlowStyle = '';
                if (emaSlowClass) {
                    const color = emaSlowClass === 'value-highest' ? '#10b981' : 
                                 emaSlowClass === 'value-middle' ? '#fbbf24' : '#ef4444';
                    emaSlowStyle = `style="color: ${color} !important; font-weight: 700 !important;"`;
                }

                // Calculate tick gaps (MNQ tick size = 0.25, so 4 ticks per point)
                const TICK_SIZE = 0.25;
                let closeToFastTicks = '-';
                let fastToSlowTicks = '-';
                let closeToFastMet = false;
                let fastToSlowMet = false;
                let closeToFastSymbol = '';
                let fastToSlowSymbol = '';
                
                // Get minimum requirements from input fields (outside if blocks for scope)
                const minTicksCloseToFastInput = document.getElementById('minTicksCloseToFast');
                const minTicksFastToSlowInput = document.getElementById('minTicksFastToSlow');
                const minTicksCloseToFast = minTicksCloseToFastInput ? (parseFloat(minTicksCloseToFastInput.value) || 0) : 0;
                const minTicksFastToSlow = minTicksFastToSlowInput ? (parseFloat(minTicksFastToSlowInput.value) || 0) : 0;
                
                // Get gradient degree thresholds
                const minGradientDegInput = document.getElementById('minGradientDeg');
                const maxGradientDegInput = document.getElementById('maxGradientDeg');
                const minGradientDeg = minGradientDegInput ? (parseFloat(minGradientDegInput.value) || 0) : 0;
                const maxGradientDeg = maxGradientDegInput ? (parseFloat(maxGradientDegInput.value) || 0) : 0;
                
                if (!isNaN(close) && !isNaN(emaFast) && close !== null && emaFast !== null) {
                    const gapCloseToFast = Math.abs(close - emaFast);
                    closeToFastTicks = (gapCloseToFast / TICK_SIZE).toFixed(2);
                    
                    // Determine if gap meets requirement based on EMA alignment
                    if (close > emaFast && emaFast > emaSlow) {
                        // Bullish: Close >= Fast EMA + minGap
                        closeToFastMet = close >= emaFast + (minTicksCloseToFast * TICK_SIZE);
                    } else if (close < emaFast && emaFast < emaSlow) {
                        // Bearish: Close <= Fast EMA - minGap
                        closeToFastMet = close <= emaFast - (minTicksCloseToFast * TICK_SIZE);
                    } else {
                        // Not aligned, check if gap is at least minimum
                        closeToFastMet = gapCloseToFast >= (minTicksCloseToFast * TICK_SIZE);
                    }
                    
                    closeToFastSymbol = minTicksCloseToFast > 0 ? (closeToFastMet ? '‚úì' : '‚úó') : '';
                }
                
                if (!isNaN(emaFast) && !isNaN(emaSlow) && emaFast !== null && emaSlow !== null) {
                    const gapFastToSlow = Math.abs(emaFast - emaSlow);
                    fastToSlowTicks = (gapFastToSlow / TICK_SIZE).toFixed(2);
                    
                    // Determine if gap meets requirement based on EMA alignment
                    if (close > emaFast && emaFast > emaSlow) {
                        // Bullish: Fast EMA >= Slow EMA + minGap
                        fastToSlowMet = emaFast >= emaSlow + (minTicksFastToSlow * TICK_SIZE);
                    } else if (close < emaFast && emaFast < emaSlow) {
                        // Bearish: Fast EMA <= Slow EMA - minGap
                        fastToSlowMet = emaFast <= emaSlow - (minTicksFastToSlow * TICK_SIZE);
                    } else {
                        // Not aligned, check if gap is at least minimum
                        fastToSlowMet = gapFastToSlow >= (minTicksFastToSlow * TICK_SIZE);
                    }
                    
                    fastToSlowSymbol = minTicksFastToSlow > 0 ? (fastToSlowMet ? '‚úì' : '‚úó') : '';
                }
                
                // Determine colors for tick gap columns: green if meets minimum, red if below minimum
                let closeToFastBgColor = '';
                let closeToFastTextColor = '#e0e0e0';
                // Check if minimum is set and we have valid tick data
                if (minTicksCloseToFast > 0 && closeToFastTicks !== '-' && !isNaN(parseFloat(closeToFastTicks))) {
                    closeToFastBgColor = closeToFastMet ? 'background-color: #10b981; ' : 'background-color: #ef4444; ';
                    closeToFastTextColor = '#ffffff';
                }
                
                let fastToSlowBgColor = '';
                let fastToSlowTextColor = '#e0e0e0';
                // Check if minimum is set and we have valid tick data
                if (minTicksFastToSlow > 0 && fastToSlowTicks !== '-' && !isNaN(parseFloat(fastToSlowTicks))) {
                    fastToSlowBgColor = fastToSlowMet ? 'background-color: #10b981; ' : 'background-color: #ef4444; ';
                    fastToSlowTextColor = '#ffffff';
                }
                
                // Determine gradient degree colors: green if meets threshold, red if below/above threshold
                // Determine potential direction based on EMA alignment, not current position
                const gradDeg = parseFloat(bar.fast_ema_grad_deg);
                let gradDegBgColor = '';
                let gradDegTextColor = '#e0e0e0';
                let gradDegMet = false;
                
                if (!isNaN(gradDeg) && gradDeg !== null && gradDeg !== undefined) {
                    // Determine potential trade direction based on EMA alignment (not current position)
                    // Bullish alignment (Close > Fast EMA > Slow EMA) = potential LONG
                    // Bearish alignment (Close < Fast EMA < Slow EMA) = potential SHORT
                    const isBullishAlignment = !isNaN(close) && !isNaN(emaFast) && !isNaN(emaSlow) && 
                                             close > emaFast && emaFast > emaSlow;
                    const isBearishAlignment = !isNaN(close) && !isNaN(emaFast) && !isNaN(emaSlow) && 
                                              close < emaFast && emaFast < emaSlow;
                    
                    // Check thresholds based on EMA alignment (potential trade direction)
                    if (isBullishAlignment && minGradientDeg !== 0) {
                        // Potential LONG: gradient should be >= minGradientDeg (positive gradient)
                        gradDegMet = gradDeg >= minGradientDeg;
                        gradDegBgColor = gradDegMet ? 'background-color: #10b981; ' : 'background-color: #ef4444; ';
                        gradDegTextColor = '#ffffff';
                    } else if (isBearishAlignment && maxGradientDeg !== 0) {
                        // Potential SHORT: gradient should be <= maxGradientDeg (negative gradient)
                        gradDegMet = gradDeg <= maxGradientDeg;
                        gradDegBgColor = gradDegMet ? 'background-color: #10b981; ' : 'background-color: #ef4444; ';
                        gradDegTextColor = '#ffffff';
                    } else if (!isBullishAlignment && !isBearishAlignment) {
                        // EMAs not aligned - check both thresholds if set
                        if (minGradientDeg !== 0 && maxGradientDeg !== 0) {
                            // Check if gradient meets either threshold (could be long or short setup)
                            gradDegMet = (gradDeg >= minGradientDeg) || (gradDeg <= maxGradientDeg);
                            gradDegBgColor = gradDegMet ? 'background-color: #10b981; ' : 'background-color: #ef4444; ';
                            gradDegTextColor = '#ffffff';
                        } else if (minGradientDeg !== 0) {
                            // Only min threshold set - check for long qualification
                            gradDegMet = gradDeg >= minGradientDeg;
                            gradDegBgColor = gradDegMet ? 'background-color: #10b981; ' : 'background-color: #ef4444; ';
                            gradDegTextColor = '#ffffff';
                        } else if (maxGradientDeg !== 0) {
                            // Only max threshold set - check for short qualification
                            gradDegMet = gradDeg <= maxGradientDeg;
                            gradDegBgColor = gradDegMet ? 'background-color: #10b981; ' : 'background-color: #ef4444; ';
                            gradDegTextColor = '#ffffff';
                        }
                    }
                }

                // Get trade info for this bar
                const barTradeInfo = tradesByBar[bar.bar_index] || {entry: null, exit: null};
                let tradeText = '-';
                let tradeStyle = '';
                let hasTrade = false;
                
                // Check if this bar is part of a trade (between entry and exit) - check ALL trades, not just active ones
                let activeTrade = null;
                const currentBarNum = bar.bar_index;
                const tradesToCheck = window.allTradesList || [];
                
                for (const trade of tradesToCheck) {
                    const entryBarNum = trade.entry_bar;
                    const exitBarNum = trade.exit_bar;
                    
                    if (entryBarNum !== null && entryBarNum !== undefined) {
                        // Bar is part of trade if it's >= entry bar and (no exit yet or <= exit bar)
                        if (currentBarNum >= entryBarNum && (exitBarNum === null || exitBarNum === undefined || currentBarNum <= exitBarNum)) {
                            activeTrade = trade;
                            break;
                        }
                    }
                }
                
                if (barTradeInfo.entry && barTradeInfo.exit) {
                    // One-bar trade (entry and exit on same bar) - show EXIT with final P&L
                    const trade = barTradeInfo.entry;
                    const pnl = parseFloat(trade.realized_points || 0);
                    const pnlColor = pnl >= 0 ? '#10b981' : '#ef4444';
                    if (Math.abs(pnl) < 0.01) {
                        // P&L is essentially zero, just show EXIT
                        tradeText = `EXIT ${trade.direction}`;
                        tradeStyle = `background-color: ${pnlColor}; color: #ffffff; font-weight: 700; text-align: center;`;
                    } else {
                        tradeText = `EXIT ${trade.direction} ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}`;
                        tradeStyle = `background-color: ${pnlColor}; color: #ffffff; font-weight: 700; text-align: center;`;
                    }
                    hasTrade = true;
                } else if (barTradeInfo.entry) {
                    // Entry bar - show entry label only (no P&L)
                    const trade = barTradeInfo.entry;
                    tradeText = `ENTRY ${trade.direction}`;
                    tradeStyle = 'background-color: #3b82f6; color: #ffffff; font-weight: 700; text-align: center;';
                    hasTrade = true;
                } else if (barTradeInfo.exit) {
                    // Exit bar - show EXIT with final P&L
                    const trade = barTradeInfo.exit;
                    const pnl = parseFloat(trade.realized_points || 0);
                    const pnlColor = pnl >= 0 ? '#10b981' : '#ef4444';
                    if (Math.abs(pnl) < 0.01) {
                        // P&L is essentially zero, just show EXIT
                        tradeText = `EXIT ${trade.direction}`;
                        tradeStyle = `background-color: ${pnlColor}; color: #ffffff; font-weight: 700; text-align: center;`;
                    } else {
                        tradeText = `EXIT ${trade.direction} ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}`;
                        tradeStyle = `background-color: ${pnlColor}; color: #ffffff; font-weight: 700; text-align: center;`;
                    }
                    hasTrade = true;
                } else if (activeTrade) {
                    // Bar is between entry and exit - show only P&L (no "ENTRY" prefix)
                    const entryPrice = parseFloat(activeTrade.entry_price || 0);
                    const currentClose = parseFloat(bar.close_price || 0);
                    let unrealizedPnl = 0;
                    
                    if (activeTrade.direction === 'LONG' && entryPrice > 0 && currentClose > 0) {
                        unrealizedPnl = currentClose - entryPrice;
                    } else if (activeTrade.direction === 'SHORT' && entryPrice > 0 && currentClose > 0) {
                        unrealizedPnl = entryPrice - currentClose;
                    }
                    
                    // Only show P&L if it's not essentially zero
                    if (Math.abs(unrealizedPnl) < 0.01) {
                        // P&L is essentially zero, show just direction
                        tradeText = activeTrade.direction;
                        tradeStyle = 'background-color: #3b82f6; color: #ffffff; font-weight: 700; text-align: center;';
                    } else {
                        const pnlColor = unrealizedPnl >= 0 ? '#10b981' : '#ef4444';
                        tradeText = `${unrealizedPnl >= 0 ? '+' : ''}${unrealizedPnl.toFixed(2)}`;
                        tradeStyle = `background-color: ${pnlColor}; color: #ffffff; font-weight: 700; text-align: center;`;
                    }
                    hasTrade = true;
                }
                
                // Highlight row if it has a trade
                if (hasTrade) {
                    row.style.backgroundColor = '#1a3a5a';
                }
                
                row.innerHTML = `
                    <td class="bar-index">
                        <a href="bar_analysis.html?bar_index=${bar.bar_index}" 
                           style="color: #667eea; text-decoration: none; font-weight: 700; cursor: pointer;"
                           title="Click to view detailed analysis for this bar"
                           onmouseover="this.style.textDecoration='underline'"
                           onmouseout="this.style.textDecoration='none'">
                            ${bar.bar_index || '-'}
                        </a>
                    </td>
                    <td>${bar.timestamp || '-'}</td>
                    <td>${formatPrice(bar.open_price)}</td>
                    <td>${formatPrice(bar.high_price)}</td>
                    <td>${formatPrice(bar.low_price)}</td>
                    <td class="${closeClass}" ${closeStyle}>${formatPrice(bar.close_price)}</td>
                    <td class="${emaFastClass}" ${emaFastStyle}>${formatPrice(bar.ema_fast_value)}</td>
                    <td class="${emaSlowClass}" ${emaSlowStyle}>${formatPrice(bar.ema_slow_value)}</td>
                    <td style="${closeToFastBgColor}color: ${closeToFastTextColor}; font-weight: 700; text-align: center;">${closeToFastTicks}${closeToFastSymbol ? ' ' + closeToFastSymbol : ''}</td>
                    <td style="${fastToSlowBgColor}color: ${fastToSlowTextColor}; font-weight: 700; text-align: center;">${fastToSlowTicks}${fastToSlowSymbol ? ' ' + fastToSlowSymbol : ''}</td>
                    <td style="${gradDegBgColor}color: ${gradDegTextColor}; font-weight: 700; text-align: center;">${formatPrice(bar.fast_ema_grad_deg) || '-'}</td>
                    <td>${bar.volume || '-'}</td>
                    <td>${formatPrice(bar.bar_range)}</td>
                    <td style="${bodyBgColor}color: ${bodyTextColor}; font-weight: 700; text-align: center;">${formatPrice(bar.body_size)}</td>
                    <td style="text-align: center;">${(bar.stop_loss_points !== null && bar.stop_loss_points !== undefined && bar.stop_loss_points !== '' && bar.stop_loss_points !== 'null' && !isNaN(parseFloat(bar.stop_loss_points))) ? parseFloat(bar.stop_loss_points).toFixed(2) : '-'}</td>
                    <td style="${tradeStyle}">${tradeText}</td>
                    <td style="text-align: left; font-size: 0.75rem; max-width: 300px; word-wrap: break-word; padding: 8px;">${(() => {
                        // Format reason string for better readability
                        const formatReason = (reasonStr) => {
                            if (!reasonStr || reasonStr === '-') return '';
                            // Split by semicolon and format each part
                            const parts = reasonStr.split(';').map(p => p.trim()).filter(p => p);
                            if (parts.length === 0) return '';
                            // Return HTML with line breaks
                            return parts.map(part => {
                                // Color-code different types
                                let color = '#e0e0e0';
                                let bgColor = '';
                                if (part.includes('FreshSignal')) {
                                    color = '#3b82f6'; // Blue
                                } else if (part.includes('Pending') || part.includes('Deferred')) {
                                    color = '#f59e0b'; // Orange
                                } else if (part.includes('Reverse')) {
                                    color = '#8b5cf6'; // Purple
                                } else if (part.includes('TrendUp') || part.includes('TrendDown')) {
                                    color = '#10b981'; // Green
                                } else if (part.includes('GradientOK') || part.includes('GradientBlocked')) {
                                    color = '#06b6d4'; // Cyan
                                } else if (part.includes('EMACrossoverOK') || part.includes('EMACrossoverBlocked')) {
                                    color = '#ec4899'; // Pink
                                } else if (part.includes('GoodCandle')) {
                                    color = '#10b981'; // Green
                                } else if (part.includes('BadCandle')) {
                                    color = '#ef4444'; // Red
                                } else if (part.includes('Stop') || part.includes('Retrace') || part.includes('Exit')) {
                                    color = '#ef4444'; // Red
                                    bgColor = 'background-color: rgba(239, 68, 68, 0.2);';
                                }
                                return `<div style="color: ${color}; ${bgColor} padding: 2px 4px; margin: 1px 0; border-radius: 2px;">${part}</div>`;
                            }).join('');
                        };
                        
                        let html = '';
                        let hasContent = false;
                        
                        // Get entry reason from trade or active trade
                        let entryReason = '';
                        if (barTradeInfo.entry) {
                            entryReason = barTradeInfo.entry.entry_reason || '';
                        } else if (activeTrade) {
                            entryReason = activeTrade.entry_reason || '';
                        }
                        
                        // Get exit reason
                        let exitReason = '';
                        if (barTradeInfo.exit) {
                            exitReason = barTradeInfo.exit.exit_reason || '';
                        } else if (barTradeInfo.entry && barTradeInfo.entry.exit_reason) {
                            exitReason = barTradeInfo.entry.exit_reason;
                        } else if (activeTrade && bar.bar_index === activeTrade.exit_bar) {
                            exitReason = activeTrade.exit_reason || '';
                        }
                        
                        // Format and display entry reason
                        if (entryReason) {
                            const formatted = formatReason(entryReason);
                            if (formatted) {
                                html += `<div style="margin-bottom: 4px;"><strong style="color: #3b82f6;">ENTRY:</strong>${formatted}</div>`;
                                hasContent = true;
                            }
                        }
                        
                        // Format and display exit reason
                        if (exitReason) {
                            const formatted = formatReason(exitReason);
                            if (formatted) {
                                html += `<div><strong style="color: #ef4444;">EXIT:</strong>${formatted}</div>`;
                                hasContent = true;
                            }
                        }
                        
                        // If no content, show dash
                        if (!hasContent) {
                            return '<span style="color: #888;">-</span>';
                        }
                        
                        // Add tooltip with full text
                        const fullText = [entryReason, exitReason].filter(r => r).join(' | ');
                        return `<div title="${fullText.replace(/"/g, '&quot;')}" style="cursor: help;">${html}</div>`;
                    })()}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${(() => {
                        const ct = bar.candle_type || '';
                        if (ct === 'good') return 'background-color: #10b981; color: #ffffff; font-weight: 700;';
                        if (ct === 'bad') return 'background-color: #ef4444; color: #ffffff; font-weight: 700;';
                        return '';
                    })()}">${bar.candle_type || '-'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.trend_up == 1 ? 'background-color: #10b981; color: #ffffff; font-weight: 700;' : ''}">${bar.trend_up == 1 ? '‚úì' : '-'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.trend_down == 1 ? 'background-color: #ef4444; color: #ffffff; font-weight: 700;' : ''}">${bar.trend_down == 1 ? '‚úì' : '-'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.allow_long_this_bar == 1 ? 'background-color: #10b981; color: #ffffff; font-weight: 700;' : 'background-color: #ef4444; color: #ffffff; font-weight: 700;'}">${bar.allow_long_this_bar == 1 ? '‚úì' : '‚úó'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.allow_short_this_bar == 1 ? 'background-color: #10b981; color: #ffffff; font-weight: 700;' : 'background-color: #ef4444; color: #ffffff; font-weight: 700;'}">${bar.allow_short_this_bar == 1 ? '‚úì' : '‚úó'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.pending_long_from_bad == 1 ? 'background-color: #f59e0b; color: #ffffff; font-weight: 700;' : ''}">${bar.pending_long_from_bad == 1 ? '‚úì' : '-'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.pending_short_from_good == 1 ? 'background-color: #f59e0b; color: #ffffff; font-weight: 700;' : ''}">${bar.pending_short_from_good == 1 ? '‚úì' : '-'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.avoid_longs_on_bad_candle == 1 ? 'background-color: #ef4444; color: #ffffff; font-weight: 700;' : ''}">${bar.avoid_longs_on_bad_candle == 1 ? 'ON' : 'OFF'}</td>
                    <td style="text-align: center; font-size: 0.8rem; ${bar.avoid_shorts_on_good_candle == 1 ? 'background-color: #ef4444; color: #ffffff; font-weight: 700;' : ''}">${bar.avoid_shorts_on_good_candle == 1 ? 'ON' : 'OFF'}</td>
                    <td>${bar.ema_fast_period || '-'}</td>
                    <td>${bar.ema_slow_period || '-'}</td>
                `;

                row.addEventListener('click', () => {
                    document.querySelectorAll('tbody tr').forEach(r => r.classList.remove('selected'));
                    row.classList.add('selected');
                });

                tbody.appendChild(row);
            });

            const maxPage = Math.ceil(filteredBars.length / pageSize) - 1;
            document.getElementById('pageInfo').textContent = 
                `Page ${currentPage + 1} of ${maxPage + 1} (${filteredBars.length} bars)`;
            document.getElementById('prevBtn').disabled = currentPage === 0;
            document.getElementById('nextBtn').disabled = currentPage >= maxPage;
        }

        function formatPrice(value) {
            if (value === null || value === undefined || value === 'null' || value === '') return '-';
            const num = parseFloat(value);
            if (isNaN(num)) return '-';
            return num.toFixed(2);
        }

        // Auto-refresh functionality
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            const autoRefreshCheckbox = document.getElementById('autoRefresh');
            if (autoRefreshCheckbox && autoRefreshCheckbox.checked) {
                autoRefreshInterval = setInterval(() => {
                    console.log('[BAR_DEBUG] Auto-refreshing...');
                    loadBars(true); // Pass true to indicate auto-refresh (don't show loading spinner)
                }, 5000); // Refresh every 5 seconds
            }
        }
        
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }
        
        // Setup auto-refresh checkbox listener
        document.addEventListener('DOMContentLoaded', () => {
            const autoRefreshCheckbox = document.getElementById('autoRefresh');
            if (autoRefreshCheckbox) {
                autoRefreshCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        startAutoRefresh();
                    } else {
                        stopAutoRefresh();
                    }
                });
            }
        });
        
        // Load data on page load
        loadBars();
        
        // Start auto-refresh after initial load
        setTimeout(() => {
            startAutoRefresh();
        }, 2000); // Wait 2 seconds after initial load
    </script>
</body>
</html>

